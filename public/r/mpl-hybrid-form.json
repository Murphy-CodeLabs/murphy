{
    "name": "mpl-hybrid-form",
    "description": "A hybrid Metaplex form to mint either a standard NFT (Token Metadata) or a compressed NFT (Bubblegum) with collection management and advanced options.",
    "type": "components:ui",
    "dependencies": [
        "@solana/web3.js",
        "@solana/wallet-adapter-react",
        "@metaplex-foundation/umi",
        "@metaplex-foundation/umi-bundle-defaults",
        "@metaplex-foundation/umi-signer-wallet-adapters",
        "@metaplex-foundation/mpl-token-metadata",
        "@metaplex-foundation/mpl-bubblegum",
        "react-hook-form",
        "@hookform/resolvers",
        "zod",
        "sonner"
    ],
    "devDependencies": [],
    "registryDependencies": [
        "card",
        "form",
        "input",
        "button",
        "textarea",
        "switch",
        "label",
        "badge",
        "alert",
        "tabs",
        "select",
        "dialog"
    ],
    "files": [
        {
            "name": "mpl-hybrid-form.tsx",
            "content": "'use client';\n\n// React v√† hooks\nimport { useState, useEffect, useContext } from 'react';\nimport { useForm } from \"react-hook-form\";\n\n// Solana\nimport { useConnection, useWallet } from '@solana/wallet-adapter-react';\nimport { PublicKey } from '@solana/web3.js';\n\n// UI components\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { ConnectWalletButton } from \"./connect-wallet-button\";\nimport {\n  Card,\n  CardContent,\n  CardHeader,\n  CardTitle,\n  CardDescription,\n} from \"@/components/ui/card\";\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"@/components/ui/form\";\nimport {\n  Tabs,\n  TabsContent,\n  TabsList,\n  TabsTrigger,\n} from \"@/components/ui/tabs\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Label } from \"@/components/ui/label\";\nimport {\n  Alert,\n  AlertDescription,\n  AlertTitle,\n} from \"@/components/ui/alert\";\n\n// Icons and notifications\nimport { toast } from \"sonner\";\nimport { \n  Loader2, \n  ExternalLink, \n  CheckCircle, \n  Plus, \n  X, \n  Shuffle, \n  Info,\n  Copy,\n  Eye\n} from \"lucide-react\";\n\n// Context\nimport { ModalContext } from \"@/components/providers/wallet-provider\";\n\n// Import Metaplex libraries\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { walletAdapterIdentity } from '@metaplex-foundation/umi-signer-wallet-adapters';\nimport { mplTokenMetadata, createNft } from '@metaplex-foundation/mpl-token-metadata';\nimport { mplBubblegum, mintToCollectionV1 } from '@metaplex-foundation/mpl-bubblegum';\nimport {\n  generateSigner,\n  publicKey as umiPublicKey,\n  some,\n  none,\n  percentAmount,\n} from '@metaplex-foundation/umi';\n\n// Types and interfaces\ninterface MplHybridResult {\n  assetAddress: string;\n  signature: string;\n  assetType: 'Standard' | 'Compressed';\n}\n\ntype MplHybridFormValues = {\n  // Asset Type\n  assetType: 'standard' | 'compressed';\n  \n  // Basic Info\n  name: string;\n  symbol: string;\n  uri: string;\n  description: string;\n  \n  // Collection\n  collectionAddress: string;\n  useExistingCollection: boolean;\n  \n  // Compressed NFT specific\n  merkleTreeAddress: string;\n  \n  // Advanced Settings\n  isMutable: boolean;\n  \n  // Creators\n  creators: Array<{\n    address: string;\n    verified: boolean;\n    share: number;\n  }>;\n};\n\nexport interface MplHybridFormProps {\n  collectionAddress?: string;\n  merkleTreeAddress?: string;\n  onAssetCreated?: (assetAddress: string, signature: string, assetType: string) => void;\n  className?: string;\n}\n\n// Form validation resolver\nconst customResolver = (data: any) => {\n  const errors: any = {};\n\n  if (!data.name?.trim()) errors.name = { type: \"required\", message: \"Name is required\" };\n  if (!data.symbol?.trim()) errors.symbol = { type: \"required\", message: \"Symbol is required\" };\n  if (!data.uri?.trim()) {\n    errors.uri = { type: \"required\", message: \"URI is required\" };\n  } else {\n    try { new URL(data.uri); } catch { errors.uri = { type: \"pattern\", message: \"Invalid URI format\" }; }\n  }\n\n  if (data.useExistingCollection) {\n    if (!data.collectionAddress?.trim()) {\n      errors.collectionAddress = { type: \"required\", message: \"Collection address is required\" };\n    } else {\n      try { new PublicKey(data.collectionAddress); } catch { errors.collectionAddress = { type: \"pattern\", message: \"Invalid collection address\" }; }\n    }\n  }\n\n  if (data.assetType === 'compressed') {\n    if (!data.merkleTreeAddress?.trim()) {\n      errors.merkleTreeAddress = { type: \"required\", message: \"Merkle Tree address is required for compressed NFTs\" };\n    } else {\n      try { new PublicKey(data.merkleTreeAddress); } catch { errors.merkleTreeAddress = { type: \"pattern\", message: \"Invalid Merkle Tree address\" }; }\n    }\n  }\n\n  if (data.creators?.length > 0) {\n    const totalShare = data.creators.reduce((sum: number, c: any) => sum + (c.share || 0), 0);\n    if (totalShare !== 100) {\n      errors.creators = { type: \"sum\", message: \"Creator shares must sum to 100%\" };\n    }\n    data.creators.forEach((c: any, i: number) => {\n      if (!c.address?.trim()) errors[`creators.${i}.address`] = { type: \"required\", message: \"Address is required\" };\n      else try { new PublicKey(c.address); } catch { errors[`creators.${i}.address`] = { type: \"pattern\", message: \"Invalid address\" }; }\n      if (c.share < 0 || c.share > 100) errors[`creators.${i}.share`] = { type: \"range\", message: \"Share must be 0-100\" };\n    });\n  }\n\n  return { values: Object.keys(errors).length === 0 ? data : {}, errors };\n};\n\nexport default function MplHybridForm({\n  collectionAddress: propCollectionAddress,\n  merkleTreeAddress: propMerkleTreeAddress,\n  onAssetCreated,\n  className\n}: MplHybridFormProps) {\n  // Hooks\n  const { connection } = useConnection();\n  const { publicKey, connected, wallet, signTransaction, signAllTransactions } = useWallet();\n  const { endpoint, switchToNextEndpoint } = useContext(ModalContext);\n\n  // State\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [mounted, setMounted] = useState(false);\n  const [network, setNetwork] = useState('devnet');\n  const [currentStage, setCurrentStage] = useState<'input' | 'confirming' | 'success' | 'error'>('input');\n  const [error, setError] = useState<string | null>(null);\n  const [result, setResult] = useState<MplHybridResult | null>(null);\n\n  // Form setup\n  const form = useForm<MplHybridFormValues>({\n    defaultValues: {\n      assetType: 'standard',\n      name: \"\",\n      symbol: \"\",\n      uri: \"\",\n      description: \"\",\n      collectionAddress: propCollectionAddress || \"\",\n      useExistingCollection: !!propCollectionAddress,\n      merkleTreeAddress: propMerkleTreeAddress || \"\",\n      isMutable: true,\n      creators: [{ address: \"\", verified: true, share: 100 }],\n    },\n    mode: \"onSubmit\",\n    resolver: customResolver,\n  });\n\n  // Effects\n  useEffect(() => { setMounted(true); }, []);\n  useEffect(() => { if (endpoint) setNetwork(endpoint.includes('devnet') ? 'devnet' : 'mainnet'); }, [endpoint]);\n  useEffect(() => {\n    if (connected && publicKey && form.getValues(\"creators\")[0].address === \"\") {\n      const creators = form.getValues(\"creators\");\n      creators[0].address = publicKey.toString();\n      form.setValue(\"creators\", creators);\n    }\n  }, [connected, publicKey, form]);\n\n  // Submit handler\n  const onSubmit = async (values: MplHybridFormValues) => {\n    if (!connected || !publicKey || !wallet) {\n      toast.error(\"Please connect your wallet\");\n      return;\n    }\n\n    setIsSubmitting(true);\n    setCurrentStage(\"confirming\");\n    setError(null);\n    const toastId = `mpl-hybrid-create`;\n    toast.loading(\"Creating Hybrid Asset...\", { id: toastId });\n\n    try {\n      const walletAdapter = { publicKey, signTransaction, signAllTransactions };\n      const umi = createUmi(connection.rpcEndpoint)\n        .use(walletAdapterIdentity(walletAdapter))\n        .use(mplTokenMetadata())\n        .use(mplBubblegum());\n\n      let collectionMintAddress = values.collectionAddress;\n      if (!values.useExistingCollection) {\n        const collectionMint = generateSigner(umi);\n        await createNft(umi, {\n          mint: collectionMint,\n          name: `${values.name} Collection`,\n          uri: values.uri, // Re-use asset URI for simplicity\n          sellerFeeBasisPoints: percentAmount(0),\n          isCollection: true,\n        }).sendAndConfirm(umi);\n        collectionMintAddress = collectionMint.publicKey.toString();\n        form.setValue('collectionAddress', collectionMintAddress);\n      }\n\n      let assetAddress: string;\n      let signature: string;\n\n      if (values.assetType === 'standard') {\n        const mint = generateSigner(umi);\n        const txResult = await createNft(umi, {\n          mint,\n          name: values.name,\n          symbol: values.symbol,\n          uri: values.uri,\n          sellerFeeBasisPoints: percentAmount(5.5),\n          collection: collectionMintAddress ? some({ key: umiPublicKey(collectionMintAddress), verified: false }) : none(),\n          creators: some(values.creators.map(c => ({ address: umiPublicKey(c.address), verified: c.verified, share: c.share }))),\n          isMutable: values.isMutable,\n        }).sendAndConfirm(umi);\n        assetAddress = mint.publicKey.toString();\n        signature = Buffer.from(txResult.signature).toString('base64');\n      } else { // Compressed\n        const txResult = await mintToCollectionV1(umi, {\n          leafOwner: umi.identity.publicKey,\n          merkleTree: umiPublicKey(values.merkleTreeAddress),\n          collectionMint: umiPublicKey(collectionMintAddress),\n          metadata: {\n            name: values.name,\n            symbol: values.symbol,\n            uri: values.uri,\n            sellerFeeBasisPoints: percentAmount(5.5),\n            collection: { key: umiPublicKey(collectionMintAddress), verified: false },\n            creators: values.creators.map(c => ({ address: umiPublicKey(c.address), verified: c.verified, share: c.share }))\n          }\n        }).sendAndConfirm(umi);\n        // Note: Getting the asset ID for cNFTs requires parsing logs, which is complex client-side.\n        // We'll use the signature as a placeholder reference.\n        assetAddress = `leaf-for-tx-${Buffer.from(txResult.signature).toString('hex').slice(0, 16)}`;\n        signature = Buffer.from(txResult.signature).toString('base64');\n      }\n\n      setResult({ assetAddress, signature, assetType: values.assetType === 'standard' ? 'Standard' : 'Compressed' });\n      if (onAssetCreated) onAssetCreated(assetAddress, signature, values.assetType);\n      setCurrentStage(\"success\");\n      toast.success(`Hybrid ${values.assetType} asset created!`, { id: toastId });\n\n    } catch (err: any) {\n      console.error(\"Error creating hybrid asset:\", err);\n      setCurrentStage(\"error\");\n      const errorMessage = err.message || \"An unknown error occurred\";\n      setError(errorMessage);\n      toast.error(\"Creation Failed\", { id: toastId, description: errorMessage });\n      if (errorMessage.includes('failed to fetch')) switchToNextEndpoint();\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // Creator management\n  const addCreator = () => form.setValue(\"creators\", [...form.getValues(\"creators\"), { address: \"\", verified: true, share: 0 }]);\n  const removeCreator = (index: number) => {\n    if (form.getValues(\"creators\").length > 1) {\n      form.setValue(\"creators\", form.getValues(\"creators\").filter((_, i) => i !== index));\n    }\n  };\n\n  // View functions\n  const viewExplorer = (sig: string) => {\n    const url = `https://explorer.solana.com/tx/${sig}?cluster=${network}`;\n    window.open(url, \"_blank\");\n  };\n\n  const copyToClipboard = (text: string) => {\n    navigator.clipboard.writeText(text);\n    toast.success(\"Copied to clipboard!\");\n  };\n\n  const resetForm = () => {\n    form.reset();\n    setResult(null);\n    setCurrentStage(\"input\");\n    setError(null);\n  };\n\n  // Render functions\n  const renderForm = () => (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n        <Tabs defaultValue=\"standard\" onValueChange={(v) => form.setValue('assetType', v as any)} className=\"w-full\">\n          <TabsList className=\"grid w-full grid-cols-2\">\n            <TabsTrigger value=\"standard\">Standard NFT</TabsTrigger>\n            <TabsTrigger value=\"compressed\">Compressed NFT</TabsTrigger>\n          </TabsList>\n        </Tabs>\n\n        {/* Basic Info */}\n        <div className=\"space-y-4\">\n          <h3 className=\"text-lg font-semibold\">Asset Metadata</h3>\n          <FormField control={form.control} name=\"name\" render={({ field }) => (<FormItem><FormLabel>Name</FormLabel><FormControl><Input placeholder=\"My Hybrid Asset\" {...field} /></FormControl><FormMessage /></FormItem>)} />\n          <div className=\"grid grid-cols-2 gap-4\">\n            <FormField control={form.control} name=\"symbol\" render={({ field }) => (<FormItem><FormLabel>Symbol</FormLabel><FormControl><Input placeholder=\"HYBD\" {...field} /></FormControl><FormMessage /></FormItem>)} />\n            <FormField control={form.control} name=\"uri\" render={({ field }) => (<FormItem><FormLabel>Metadata URI</FormLabel><FormControl><Input placeholder=\"https://example.com/metadata.json\" {...field} /></FormControl><FormMessage /></FormItem>)} />\n          </div>\n        </div>\n\n        {/* Collection & Type Specifics */}\n        <div className=\"space-y-4\">\n          <h3 className=\"text-lg font-semibold\">Configuration</h3>\n          <FormField control={form.control} name=\"useExistingCollection\" render={({ field }) => (<FormItem className=\"flex items-center space-x-2\"><FormControl><Switch checked={field.value} onCheckedChange={field.onChange} /></FormControl><Label>Use Existing Collection</Label></FormItem>)} />\n          {form.watch(\"useExistingCollection\") && <FormField control={form.control} name=\"collectionAddress\" render={({ field }) => (<FormItem><FormLabel>Collection Address</FormLabel><FormControl><Input placeholder=\"Collection mint address\" {...field} /></FormControl><FormMessage /></FormItem>)} />}\n          {form.watch(\"assetType\") === 'compressed' && <FormField control={form.control} name=\"merkleTreeAddress\" render={({ field }) => (<FormItem><FormLabel>Merkle Tree Address</FormLabel><FormControl><Input placeholder=\"Merkle tree address\" {...field} /></FormControl><FormMessage /></FormItem>)} />}\n        </div>\n\n        {/* Creators */}\n        <div className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <h3 className=\"text-lg font-semibold\">Creators</h3>\n            <Button type=\"button\" variant=\"outline\" size=\"sm\" onClick={addCreator}><Plus className=\"h-4 w-4 mr-2\" />Add</Button>\n          </div>\n          {form.watch(\"creators\").map((_, index) => (\n            <div key={index} className=\"flex gap-2 items-end border p-2 rounded-md\">\n              <FormField control={form.control} name={`creators.${index}.address`} render={({ field }) => (<FormItem className=\"flex-1\"><FormLabel>Address</FormLabel><FormControl><Input placeholder=\"Creator address\" {...field} /></FormControl><FormMessage /></FormItem>)} />\n              <FormField control={form.control} name={`creators.${index}.share`} render={({ field }) => (<FormItem className=\"w-24\"><FormLabel>Share %</FormLabel><FormControl><Input type=\"number\" placeholder=\"100\" {...field} onChange={e => field.onChange(parseInt(e.target.value) || 0)} /></FormControl><FormMessage /></FormItem>)} />\n              <Button type=\"button\" variant=\"ghost\" size=\"icon\" onClick={() => removeCreator(index)} disabled={form.getValues(\"creators\").length === 1}><X className=\"h-4 w-4\" /></Button>\n            </div>\n          ))}\n        </div>\n\n        {/* Submit */}\n        <div className=\"pt-4\">\n          {!connected ? <ConnectWalletButton className=\"w-full\" /> : <Button type=\"submit\" disabled={isSubmitting} className=\"w-full\"><Shuffle className=\"mr-2 h-4 w-4\" />Create Hybrid Asset</Button>}\n        </div>\n      </form>\n    </Form>\n  );\n\n  const renderSuccess = () => (\n    <div className=\"space-y-4 text-center\">\n      <CheckCircle className=\"h-16 w-16 text-green-500 mx-auto\" />\n      <h3 className=\"text-xl font-bold\">Asset Created!</h3>\n      <p className=\"text-muted-foreground\">Your {result?.assetType} asset has been successfully created.</p>\n      <div className=\"space-y-2 text-left bg-muted p-3 rounded-md font-mono text-sm\">\n        <div className=\"flex justify-between items-center\"><span>Asset:</span><Button variant=\"ghost\" size=\"sm\" onClick={() => copyToClipboard(result?.assetAddress || '')}>{result?.assetAddress.slice(0, 8)}...<Copy className=\"ml-2 h-4 w-4\" /></Button></div>\n        <div className=\"flex justify-between items-center\"><span>Signature:</span><Button variant=\"ghost\" size=\"sm\" onClick={() => viewExplorer(result?.signature || '')}>{result?.signature.slice(0, 8)}...<ExternalLink className=\"ml-2 h-4 w-4\" /></Button></div>\n      </div>\n      <Button onClick={resetForm} className=\"w-full\">Create Another</Button>\n    </div>\n  );\n\n  const renderError = () => (\n    <div className=\"space-y-4 text-center\">\n      <X className=\"h-16 w-16 text-red-500 mx-auto\" />\n      <h3 className=\"text-xl font-bold\">Creation Failed</h3>\n      <Alert variant=\"destructive\"><AlertDescription>{error}</AlertDescription></Alert>\n      <Button onClick={() => setCurrentStage('input')} className=\"w-full\">Try Again</Button>\n    </div>\n  );\n\n  const renderConfirming = () => (\n    <div className=\"flex flex-col items-center justify-center space-y-4 p-8\">\n      <Loader2 className=\"h-16 w-16 animate-spin\" />\n      <h3 className=\"text-xl font-bold\">Creating Asset</h3>\n      <p className=\"text-muted-foreground\">Please confirm the transaction in your wallet...</p>\n    </div>\n  );\n\n  const renderStageContent = () => {\n    switch (currentStage) {\n      case \"success\": return renderSuccess();\n      case \"error\": return renderError();\n      case \"confirming\": return renderConfirming();\n      default: return renderForm();\n    }\n  };\n\n  if (!mounted) return <div className=\"flex justify-center items-center p-8\"><Loader2 className=\"h-8 w-8 animate-spin\" /></div>;\n\n  return (\n    <Card className={className}>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2\"><Shuffle />MPL Hybrid Form</CardTitle>\n        <CardDescription>Create Standard or Compressed NFTs from one place.</CardDescription>\n      </CardHeader>\n      <CardContent>{renderStageContent()}</CardContent>\n    </Card>\n  );\n}\n"
        }
    ],
    "category": "Metaplex",
    "subcategory": "MPL-Hybrid",
    "tags": [
        "nft",
        "compressed-nft",
        "cnft",
        "standard-nft",
        "hybrid",
        "metaplex",
        "bubblegum",
        "token-metadata",
        "solana",
        "form",
        "mint"
    ]
}