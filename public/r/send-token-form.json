{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "send-token-form",
  "type": "registry:block",
  "title": "Send Token Form",
  "description": "A simple send token form component.",
  "dependencies": [
    "@solana/web3.js",
    "@solana/spl-token",
    "@solana/wallet-adapter-react"
  ],
  "registryDependencies": [
    "input",
    "button",
    "form",
    "card",
    "sonner",
    "select"
  ],
  "files": [
    {
      "path": "components/ui/murphis/send-token-form.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect, useMemo } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { toast } from \"sonner\";\nimport { ArrowRight, Loader2, Wallet } from \"lucide-react\";\nimport {\n  PublicKey,\n  Transaction,\n  SystemProgram,\n  LAMPORTS_PER_SOL,\n} from \"@solana/web3.js\";\nimport { useWallet, useConnection } from \"@solana/wallet-adapter-react\";\nimport {\n  createTransferInstruction,\n  getAssociatedTokenAddress,\n} from \"@solana/spl-token\";\n\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n  SelectGroup,\n} from \"@/components/ui/select\";\nimport { ConnetWalletButton } from \"./connect-wallet-button\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\n\n// Type for our form values\ntype FormValues = {\n  destination: string;\n  amount: number | undefined;\n  token: string;\n};\n\n// Type for token options\nexport type TokenInfo = {\n  id: string;\n  symbol: string;\n  name: string;\n  balance: number;\n  decimals: number;\n  mintAddress?: string;\n  icon?: string;\n};\n\n// Create a custom resolver that doesn't cause deep instantiation error\nconst customResolver = (data: any) => {\n  const errors: any = {};\n\n  // Validate destination\n  if (!data.destination) {\n    errors.destination = {\n      type: \"required\",\n      message: \"Destination address is required\",\n    };\n  } else if (data.destination.length < 32) {\n    errors.destination = {\n      type: \"minLength\",\n      message: \"Destination address must be a valid Solana address\",\n    };\n  }\n\n  // Validate amount\n  if (data.amount === undefined || data.amount === null || data.amount === \"\") {\n    errors.amount = {\n      type: \"required\",\n      message: \"Amount is required\",\n    };\n  } else if (Number(data.amount) <= 0) {\n    errors.amount = {\n      type: \"min\",\n      message: \"Amount must be greater than 0\",\n    };\n  }\n\n  // Validate token\n  if (!data.token) {\n    errors.token = {\n      type: \"required\",\n      message: \"Please select a token\",\n    };\n  }\n\n  return {\n    values: Object.keys(errors).length === 0 ? data : {},\n    errors,\n  };\n};\n\nexport interface SendTokenFormProps {\n  onSendToken?: (values: FormValues) => Promise<void>;\n  tokens?: TokenInfo[];\n  isLoading?: boolean;\n  showTokenBalance?: boolean;\n  validateDestination?: (address: string) => Promise<boolean>;\n  className?: string;\n}\n\nexport function SendTokenForm({\n  onSendToken,\n  tokens,\n  isLoading = false,\n  showTokenBalance = true,\n  validateDestination,\n  className,\n}: SendTokenFormProps) {\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [selectedToken, setSelectedToken] = useState<TokenInfo | null>(null);\n  const [isLoadingTokens, setIsLoadingTokens] = useState(false);\n  const [isUpdatingBalance, setIsUpdatingBalance] = useState(false);\n  const { publicKey, connected, sendTransaction } = useWallet();\n  const { connection } = useConnection();\n  const [amountValue, setAmountValue] = useState<string>(\"\");\n\n  // Default form with explicit type to avoid deep instantiation error\n  const form = useForm<FormValues>({\n    defaultValues: {\n      destination: \"\",\n      amount: undefined,\n      token: \"\",\n    },\n    resolver: customResolver,\n  });\n\n  // Load available tokens from wallet\n  const [availableTokens, setAvailableTokens] = useState<TokenInfo[]>([]);\n\n  // Determine network from connection endpoint\n  const networkName = useMemo(() => {\n    if (!connection) return \"Unknown\";\n\n    const endpoint = connection.rpcEndpoint;\n\n    if (endpoint.includes(\"devnet\")) return \"Devnet\";\n    if (endpoint.includes(\"testnet\")) return \"Testnet\";\n    if (endpoint.includes(\"mainnet\")) return \"Mainnet\";\n    if (endpoint.includes(\"localhost\") || endpoint.includes(\"127.0.0.1\"))\n      return \"Localnet\";\n\n    // Custom endpoint - show partial URL\n    const url = new URL(endpoint);\n    return url.hostname;\n  }, [connection]);\n\n  // Fetch token accounts from devnet\n  const fetchTokenAccounts = async (ownerPublicKey: PublicKey) => {\n    try {\n      setIsLoadingTokens(true);\n\n      // Default SOL token\n      let solBalance = 0;\n\n      // Get SOL balance using connection from provider\n      try {\n        solBalance =\n          (await connection.getBalance(ownerPublicKey)) / LAMPORTS_PER_SOL;\n      } catch (error) {\n        console.error(\"Error fetching SOL balance:\", error);\n      }\n\n      // Always include SOL with the real balance\n      const defaultTokens: TokenInfo[] = [\n        {\n          id: \"sol\",\n          symbol: \"SOL\",\n          name: \"Solana\",\n          balance: solBalance,\n          decimals: 9,\n          mintAddress: \"So11111111111111111111111111111111111111112\", // Native SOL mint address\n          icon: \"/crypto-logos/solana-logo.svg\",\n        },\n      ];\n\n      // Fetch SPL tokens using the provider connection\n      const splTokens: TokenInfo[] = [];\n\n      try {\n        // Use getParsedTokenAccountsByOwner from the provider connection\n        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(\n          ownerPublicKey,\n          {\n            programId: new PublicKey(\n              \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n            ),\n          }\n        );\n\n        for (const account of tokenAccounts.value) {\n          const accountData = account.account.data.parsed.info;\n          const mintAddress = accountData.mint;\n          const tokenAmount = accountData.tokenAmount;\n\n          if (tokenAmount.uiAmount > 0) {\n            // Only include tokens with non-zero balance\n            splTokens.push({\n              id: mintAddress,\n              symbol: mintAddress.substring(0, 4) + \"...\", // Use shortened mint as symbol if no metadata\n              name: \"Token \" + mintAddress.substring(0, 6), // Use shortened mint as name if no metadata\n              balance: tokenAmount.uiAmount,\n              decimals: tokenAmount.decimals,\n              mintAddress: mintAddress,\n            });\n          }\n        }\n      } catch (error) {\n        console.error(\"Error fetching SPL token accounts:\", error);\n      }\n\n      // Return combined tokens - using spread operator to combine arrays\n      return [...defaultTokens, ...splTokens];\n    } catch (error) {\n      console.error(\"Error fetching token accounts:\", error);\n      // Return basic SOL token on error\n      return [\n        {\n          id: \"sol\",\n          symbol: \"SOL\",\n          name: \"Solana\",\n          balance: 0,\n          decimals: 9,\n          icon: \"/crypto-logos/solana-logo.svg\",\n        },\n      ];\n    } finally {\n      setIsLoadingTokens(false);\n    }\n  };\n\n  useEffect(() => {\n    // If tokens are provided as props, use those\n    if (tokens) {\n      setAvailableTokens(tokens);\n    }\n    // Otherwise, if wallet is connected, fetch tokens\n    else if (connected && publicKey) {\n      fetchTokenAccounts(publicKey)\n        .then((fetchedTokens) => {\n          setAvailableTokens(fetchedTokens);\n        })\n        .catch((error) => {\n          console.error(\"Error setting tokens:\", error);\n          // Set default SOL token on error\n          setAvailableTokens([\n            {\n              id: \"sol\",\n              symbol: \"SOL\",\n              name: \"Solana\",\n              balance: 0,\n              decimals: 9,\n              icon: \"/crypto-logos/solana-logo.svg\",\n            },\n          ]);\n        });\n    }\n  }, [tokens, connected, publicKey]);\n\n  // Validate Solana address\n  const isValidSolanaAddress = async (address: string): Promise<boolean> => {\n    try {\n      if (validateDestination) {\n        return await validateDestination(address);\n      }\n\n      // Basic validation - check if it's a valid Solana public key format\n      new PublicKey(address);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  };\n\n  // Handle form submission with actual token transfer\n  async function handleSubmit(values: FormValues) {\n    if (!connected || !publicKey || !connection) {\n      toast.error(\"Wallet not connected\", {\n        description: \"Please connect your wallet to send tokens\",\n      });\n      return;\n    }\n\n    const isValid = await isValidSolanaAddress(values.destination);\n    if (!isValid) {\n      toast.error(\"Invalid destination address\", {\n        description: \"Please enter a valid Solana address\",\n      });\n      return;\n    }\n\n    try {\n      setIsSubmitting(true);\n\n      toast.message(\"Processing transaction...\", {\n        description: \"Preparing to send tokens to destination address\",\n      });\n\n      if (onSendToken) {\n        await onSendToken(values);\n      } else {\n        const destinationPubkey = new PublicKey(values.destination);\n        const selectedTokenInfo = availableTokens.find(\n          (t) => t.id === values.token\n        );\n\n        if (!selectedTokenInfo || values.amount === undefined) {\n          throw new Error(\"Invalid token or amount\");\n        }\n\n        const transaction = new Transaction();\n\n        if (values.token === \"sol\") {\n          transaction.add(\n            SystemProgram.transfer({\n              fromPubkey: publicKey,\n              toPubkey: destinationPubkey,\n              lamports: Math.floor(values.amount * LAMPORTS_PER_SOL),\n            })\n          );\n        } else if (selectedTokenInfo.mintAddress) {\n          const mintPubkey = new PublicKey(selectedTokenInfo.mintAddress);\n          const senderATA = await getAssociatedTokenAddress(\n            mintPubkey,\n            publicKey\n          );\n          const receiverATA = await getAssociatedTokenAddress(\n            mintPubkey,\n            destinationPubkey\n          );\n\n          transaction.add(\n            createTransferInstruction(\n              senderATA,\n              receiverATA,\n              publicKey,\n              Math.floor(\n                values.amount * Math.pow(10, selectedTokenInfo.decimals)\n              )\n            )\n          );\n        }\n\n        const { blockhash } = await connection.getLatestBlockhash();\n        transaction.recentBlockhash = blockhash;\n        transaction.feePayer = publicKey;\n\n        const signature = await sendTransaction(transaction, connection);\n\n        toast.message(\"Transaction sent\", {\n          description: \"Waiting for confirmation...\",\n        });\n\n        try {\n          let confirmed = false;\n          let retries = 0;\n          const maxRetries = 30;\n\n          while (!confirmed && retries < maxRetries) {\n            retries++;\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n            const { value } = await connection.getSignatureStatus(signature);\n\n            if (\n              value?.confirmationStatus === \"confirmed\" ||\n              value?.confirmationStatus === \"finalized\"\n            ) {\n              confirmed = true;\n              break;\n            }\n          }\n\n          if (!confirmed) {\n            throw new Error(\n              \"Transaction confirmation timed out. Please check your wallet for status.\"\n            );\n          }\n        } catch (confirmError) {\n          console.error(\"Error confirming transaction:\", confirmError);\n          toast.warning(\"Transaction sent but confirmation failed\", {\n            description:\n              \"Your transaction was submitted but we couldn't confirm it. Please check your wallet for status.\",\n          });\n        }\n      }\n\n      toast.success(\"Transaction complete\", {\n        description: `Successfully sent ${values.amount} ${\n          selectedToken?.symbol || values.token\n        } to ${values.destination.slice(0, 6)}...${values.destination.slice(\n          -4\n        )}`,\n      });\n\n      if (publicKey) {\n        setIsUpdatingBalance(true);\n\n        setTimeout(async () => {\n          try {\n            const updatedTokens = await fetchTokenAccounts(publicKey);\n\n            setAvailableTokens((prevTokens) => {\n              return prevTokens.map((token) => {\n                const updatedToken = updatedTokens.find(\n                  (t) => t.id === token.id\n                );\n                if (updatedToken) {\n                  return { ...token, balance: updatedToken.balance };\n                }\n                return token;\n              });\n            });\n\n            if (selectedToken) {\n              const updatedToken = updatedTokens.find(\n                (t) => t.id === selectedToken.id\n              );\n              if (updatedToken) {\n                setSelectedToken((prev) =>\n                  prev ? { ...prev, balance: updatedToken.balance } : null\n                );\n              }\n            }\n\n            toast.message(\"Balance updated\", {\n              description: \"Your token balances have been refreshed\",\n            });\n          } catch (error) {\n            console.error(\"Error updating balances:\", error);\n          } finally {\n            setIsUpdatingBalance(false);\n          }\n        }, 2000);\n      }\n\n      const currentTokenValue = form.getValues(\"token\");\n      form.reset({\n        destination: \"\",\n        amount: undefined,\n        token: currentTokenValue,\n      });\n      setAmountValue(\"\");\n    } catch (error) {\n      console.error(\"Transaction error:\", error);\n      toast.error(\"Transaction failed\", {\n        description:\n          error instanceof Error ? error.message : \"Unknown error occurred\",\n      });\n    } finally {\n      setTimeout(() => {\n        setIsSubmitting(false);\n      }, 1000);\n    }\n  }\n\n  const handleTokenChange = (value: string) => {\n    const token = availableTokens.find((t) => t.id === value);\n    if (token) {\n      setSelectedToken(token);\n      form.setValue(\"token\", value);\n    }\n  };\n\n  const renderTokenItem = (token: TokenInfo) => (\n    <SelectItem key={token.id} value={token.id}>\n      <div className=\"flex items-center justify-between w-full\">\n        <div className=\"flex items-center\">\n          {token.icon && (\n            <div className=\"w-5 h-5 mr-2 rounded-full overflow-hidden flex items-center justify-center\">\n              <img\n                src={token.icon || \"/placeholder.svg\"}\n                alt={token.symbol}\n                className=\"w-4 h-4 object-contain\"\n                onError={(e) => {\n                  (e.target as HTMLImageElement).style.display = \"none\";\n                }}\n              />\n            </div>\n          )}\n          <span>{token.symbol}</span>\n        </div>\n        {showTokenBalance && (\n          <span className=\"text-muted-foreground ml-2 text-sm\">\n            {token.balance.toLocaleString(undefined, {\n              minimumFractionDigits: 0,\n              maximumFractionDigits: token.decimals > 6 ? 6 : token.decimals,\n            })}\n          </span>\n        )}\n      </div>\n    </SelectItem>\n  );\n\n  return (\n    <Card className={className}>\n      <CardHeader>\n        <CardTitle className=\"flex items-center\">\n          <Wallet className=\"h-5 w-5 mr-2\" />\n          Send Tokens\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        <Form {...form}>\n          <form onSubmit={(e) => e.preventDefault()} className=\"space-y-6\">\n            <FormField\n              control={form.control}\n              name=\"destination\"\n              render={({ field }) => (\n                <FormItem className=\"flex flex-col\">\n                  <FormLabel>Destination Address</FormLabel>\n                  <FormControl>\n                    <Input\n                      placeholder=\"Enter wallet address\"\n                      {...field}\n                      disabled={!connected}\n                    />\n                  </FormControl>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n              <FormField\n                control={form.control}\n                name=\"token\"\n                render={({ field }) => (\n                  <FormItem className=\"flex flex-col\">\n                    <FormLabel>Token</FormLabel>\n                    <Select\n                      onValueChange={handleTokenChange}\n                      defaultValue={field.value}\n                      disabled={!connected}\n                    >\n                      <FormControl>\n                        <SelectTrigger className=\"w-full min-w-[180px]\">\n                          <SelectValue\n                            placeholder={\n                              isLoadingTokens || isUpdatingBalance\n                                ? \"Loading tokens...\"\n                                : \"Select a token\"\n                            }\n                          />\n                        </SelectTrigger>\n                      </FormControl>\n                      <SelectContent>\n                        {isLoadingTokens || isUpdatingBalance ? (\n                          <div className=\"flex items-center justify-center p-2\">\n                            <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\n                            <span>\n                              {isUpdatingBalance\n                                ? \"Updating balances...\"\n                                : \"Loading tokens...\"}\n                            </span>\n                          </div>\n                        ) : availableTokens.length > 0 ? (\n                          <SelectGroup>\n                            {availableTokens.map(renderTokenItem)}\n                          </SelectGroup>\n                        ) : (\n                          <div className=\"p-2 text-muted-foreground text-center\">\n                            No tokens found\n                          </div>\n                        )}\n                      </SelectContent>\n                    </Select>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n\n              <FormField\n                control={form.control}\n                name=\"amount\"\n                render={({ field }) => (\n                  <FormItem className=\"flex flex-col\">\n                    <div className=\"flex justify-between items-center\">\n                      <FormLabel>Amount</FormLabel>\n                    </div>\n                    <FormControl>\n                      <Input\n                        type=\"number\"\n                        placeholder=\"0.0\"\n                        step=\"any\"\n                        value={amountValue}\n                        onChange={(e) => {\n                          setAmountValue(e.target.value);\n                          field.onChange(\n                            e.target.value === \"\"\n                              ? undefined\n                              : Number.parseFloat(e.target.value)\n                          );\n                        }}\n                        disabled={!connected}\n                      />\n                    </FormControl>\n                    {selectedToken && showTokenBalance && (\n                      <p className=\"text-xs text-muted-foreground mt-1\">\n                        Available:{\" \"}\n                        {selectedToken.balance.toLocaleString(undefined, {\n                          minimumFractionDigits: 0,\n                          maximumFractionDigits:\n                            selectedToken.decimals > 6\n                              ? 6\n                              : selectedToken.decimals,\n                        })}{\" \"}\n                        {selectedToken.symbol}\n                      </p>\n                    )}\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n            </div>\n\n            {connected ? (\n              <Button\n                type=\"button\"\n                onClick={() => form.handleSubmit(handleSubmit)()}\n                className=\"w-full\"\n                disabled={isSubmitting || isLoading || isLoadingTokens}\n              >\n                {isSubmitting ? (\n                  <>\n                    <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                    Processing Transaction...\n                  </>\n                ) : (\n                  <>\n                    Send Tokens\n                    <ArrowRight className=\"ml-2 h-4 w-4\" />\n                  </>\n                )}\n              </Button>\n            ) : (\n              <ConnetWalletButton className=\"w-full\">\n                Connect Wallet\n              </ConnetWalletButton>\n            )}\n\n            {connected && (\n              <div className=\"pt-4 border-t\">\n                <div className=\"flex items-center justify-between text-sm text-muted-foreground\">\n                  <span>Network</span>\n                  <span className=\"font-medium bg-muted px-2 py-1 rounded\">\n                    {networkName}\n                  </span>\n                </div>\n              </div>\n            )}\n          </form>\n        </Form>\n      </CardContent>\n    </Card>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/ui/murphis/send-token-form.tsx"
    }
  ]
}