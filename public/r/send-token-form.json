{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "send-token-form",
  "type": "registry:block",
  "title": "Send Token Form",
  "description": "A simple send token form component.",
  "dependencies": [
    "@solana/web3.js",
    "@solana/spl-token",
    "@solana/wallet-adapter-react"
  ],
  "registryDependencies": [
    "input",
    "button",
    "form",
    "card",
    "sonner",
    "select",
    "dialog",
    "dropdown-menu",
    "collapsible",
    "tabs"
  ],
  "files": [
    {
      "path": "components/ui/murphy/send-token-form.tsx",
      "content": "\"use client\";\r\n\r\nimport { useState, useEffect, useMemo } from \"react\";\r\nimport { useForm } from \"react-hook-form\";\r\nimport { toast } from \"sonner\";\r\nimport { ArrowRight, Loader2, Wallet } from \"lucide-react\";\r\nimport {\r\n  PublicKey,\r\n  Transaction,\r\n  SystemProgram,\r\n  LAMPORTS_PER_SOL,\r\n} from \"@solana/web3.js\";\r\nimport { useWallet, useConnection } from \"@solana/wallet-adapter-react\";\r\nimport {\r\n  createTransferInstruction,\r\n  getAssociatedTokenAddress,\r\n} from \"@solana/spl-token\";\r\n\r\nimport { Button } from \"@/components/ui/button\";\r\nimport {\r\n  Form,\r\n  FormControl,\r\n  FormField,\r\n  FormItem,\r\n  FormLabel,\r\n  FormMessage,\r\n} from \"@/components/ui/form\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n  SelectGroup,\r\n} from \"@/components/ui/select\";\r\nimport { ConnectWalletButton } from \"./connect-wallet-button\";\r\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\r\n\r\n// Type for our form values\r\ntype FormValues = {\r\n  destination: string;\r\n  amount: number | undefined;\r\n  token: string;\r\n};\r\n\r\n// Type for token options\r\nexport type TokenInfo = {\r\n  id: string;\r\n  symbol: string;\r\n  name: string;\r\n  balance: number;\r\n  decimals: number;\r\n  mintAddress?: string;\r\n  icon?: string;\r\n};\r\n\r\n// Create a custom resolver that doesn't cause deep instantiation error\r\nconst customResolver = (data: any) => {\r\n  const errors: any = {};\r\n\r\n  // Validate destination\r\n  if (!data.destination) {\r\n    errors.destination = {\r\n      type: \"required\",\r\n      message: \"Destination address is required\",\r\n    };\r\n  } else if (data.destination.length < 32) {\r\n    errors.destination = {\r\n      type: \"minLength\",\r\n      message: \"Destination address must be a valid Solana address\",\r\n    };\r\n  }\r\n\r\n  // Validate amount\r\n  if (data.amount === undefined || data.amount === null || data.amount === \"\") {\r\n    errors.amount = {\r\n      type: \"required\",\r\n      message: \"Amount is required\",\r\n    };\r\n  } else if (Number(data.amount) <= 0) {\r\n    errors.amount = {\r\n      type: \"min\",\r\n      message: \"Amount must be greater than 0\",\r\n    };\r\n  }\r\n\r\n  // Validate token\r\n  if (!data.token) {\r\n    errors.token = {\r\n      type: \"required\",\r\n      message: \"Please select a token\",\r\n    };\r\n  }\r\n\r\n  return {\r\n    values: Object.keys(errors).length === 0 ? data : {},\r\n    errors,\r\n  };\r\n};\r\n\r\nexport interface SendTokenFormProps {\r\n  onSendToken?: (values: FormValues) => Promise<void>;\r\n  tokens?: TokenInfo[];\r\n  isLoading?: boolean;\r\n  showTokenBalance?: boolean;\r\n  validateDestination?: (address: string) => Promise<boolean>;\r\n  className?: string;\r\n}\r\n\r\nexport function SendTokenForm({\r\n  onSendToken,\r\n  tokens,\r\n  isLoading = false,\r\n  showTokenBalance = true,\r\n  validateDestination,\r\n  className,\r\n}: SendTokenFormProps) {\r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n  const [selectedToken, setSelectedToken] = useState<TokenInfo | null>(null);\r\n  const [isLoadingTokens, setIsLoadingTokens] = useState(false);\r\n  const [isUpdatingBalance, setIsUpdatingBalance] = useState(false);\r\n  const { publicKey, connected, sendTransaction } = useWallet();\r\n  const { connection } = useConnection();\r\n  const [amountValue, setAmountValue] = useState<string>(\"\");\r\n\r\n  // Default form with explicit type to avoid deep instantiation error\r\n  const form = useForm<FormValues>({\r\n    defaultValues: {\r\n      destination: \"\",\r\n      amount: undefined,\r\n      token: \"\",\r\n    },\r\n    resolver: customResolver,\r\n  });\r\n\r\n  // Load available tokens from wallet\r\n  const [availableTokens, setAvailableTokens] = useState<TokenInfo[]>([]);\r\n\r\n  // Determine network from connection endpoint\r\n  const networkName = useMemo(() => {\r\n    if (!connection) return \"Unknown\";\r\n\r\n    const endpoint = connection.rpcEndpoint;\r\n\r\n    if (endpoint.includes(\"devnet\")) return \"Devnet\";\r\n    if (endpoint.includes(\"testnet\")) return \"Testnet\";\r\n    if (endpoint.includes(\"mainnet\")) return \"Mainnet\";\r\n    if (endpoint.includes(\"localhost\") || endpoint.includes(\"127.0.0.1\"))\r\n      return \"Localnet\";\r\n\r\n    // Custom endpoint - show partial URL\r\n    const url = new URL(endpoint);\r\n    return url.hostname;\r\n  }, [connection]);\r\n\r\n  // Fetch token accounts from devnet\r\n  const fetchTokenAccounts = async (ownerPublicKey: PublicKey) => {\r\n    try {\r\n      setIsLoadingTokens(true);\r\n\r\n      // Default SOL token\r\n      let solBalance = 0;\r\n\r\n      // Get SOL balance using connection from provider\r\n      try {\r\n        solBalance =\r\n          (await connection.getBalance(ownerPublicKey)) / LAMPORTS_PER_SOL;\r\n      } catch (error) {\r\n        console.error(\"Error fetching SOL balance:\", error);\r\n      }\r\n\r\n      // Always include SOL with the real balance\r\n      const defaultTokens: TokenInfo[] = [\r\n        {\r\n          id: \"sol\",\r\n          symbol: \"SOL\",\r\n          name: \"Solana\",\r\n          balance: solBalance,\r\n          decimals: 9,\r\n          mintAddress: \"So11111111111111111111111111111111111111112\", // Native SOL mint address\r\n          icon: \"/crypto-logos/solana-logo.svg\",\r\n        },\r\n      ];\r\n\r\n      // Fetch SPL tokens using the provider connection\r\n      const splTokens: TokenInfo[] = [];\r\n\r\n      try {\r\n        // Use getParsedTokenAccountsByOwner from the provider connection\r\n        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(\r\n          ownerPublicKey,\r\n          {\r\n            programId: new PublicKey(\r\n              \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\r\n            ),\r\n          }\r\n        );\r\n\r\n        for (const account of tokenAccounts.value) {\r\n          const accountData = account.account.data.parsed.info;\r\n          const mintAddress = accountData.mint;\r\n          const tokenAmount = accountData.tokenAmount;\r\n\r\n          if (tokenAmount.uiAmount > 0) {\r\n            // Only include tokens with non-zero balance\r\n            splTokens.push({\r\n              id: mintAddress,\r\n              symbol: mintAddress.substring(0, 4) + \"...\", // Use shortened mint as symbol if no metadata\r\n              name: \"Token \" + mintAddress.substring(0, 6), // Use shortened mint as name if no metadata\r\n              balance: tokenAmount.uiAmount,\r\n              decimals: tokenAmount.decimals,\r\n              mintAddress: mintAddress,\r\n            });\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Error fetching SPL token accounts:\", error);\r\n      }\r\n\r\n      // Return combined tokens - using spread operator to combine arrays\r\n      return [...defaultTokens, ...splTokens];\r\n    } catch (error) {\r\n      console.error(\"Error fetching token accounts:\", error);\r\n      // Return basic SOL token on error\r\n      return [\r\n        {\r\n          id: \"sol\",\r\n          symbol: \"SOL\",\r\n          name: \"Solana\",\r\n          balance: 0,\r\n          decimals: 9,\r\n          icon: \"/crypto-logos/solana-logo.svg\",\r\n        },\r\n      ];\r\n    } finally {\r\n      setIsLoadingTokens(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    // If tokens are provided as props, use those\r\n    if (tokens) {\r\n      setAvailableTokens(tokens);\r\n    }\r\n    // Otherwise, if wallet is connected, fetch tokens\r\n    else if (connected && publicKey) {\r\n      fetchTokenAccounts(publicKey)\r\n        .then((fetchedTokens) => {\r\n          setAvailableTokens(fetchedTokens);\r\n        })\r\n        .catch((error) => {\r\n          console.error(\"Error setting tokens:\", error);\r\n          // Set default SOL token on error\r\n          setAvailableTokens([\r\n            {\r\n              id: \"sol\",\r\n              symbol: \"SOL\",\r\n              name: \"Solana\",\r\n              balance: 0,\r\n              decimals: 9,\r\n              icon: \"/crypto-logos/solana-logo.svg\",\r\n            },\r\n          ]);\r\n        });\r\n    }\r\n  }, [tokens, connected, publicKey]);\r\n\r\n  // Validate Solana address\r\n  const isValidSolanaAddress = async (address: string): Promise<boolean> => {\r\n    try {\r\n      if (validateDestination) {\r\n        return await validateDestination(address);\r\n      }\r\n\r\n      // Basic validation - check if it's a valid Solana public key format\r\n      new PublicKey(address);\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Handle form submission with actual token transfer\r\n  async function handleSubmit(values: FormValues) {\r\n    if (!connected || !publicKey || !connection) {\r\n      toast.error(\"Wallet not connected\", {\r\n        description: \"Please connect your wallet to send tokens\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    const isValid = await isValidSolanaAddress(values.destination);\r\n    if (!isValid) {\r\n      toast.error(\"Invalid destination address\", {\r\n        description: \"Please enter a valid Solana address\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsSubmitting(true);\r\n\r\n      toast.message(\"Processing transaction...\", {\r\n        description: \"Preparing to send tokens to destination address\",\r\n      });\r\n\r\n      if (onSendToken) {\r\n        await onSendToken(values);\r\n      } else {\r\n        const destinationPubkey = new PublicKey(values.destination);\r\n        const selectedTokenInfo = availableTokens.find(\r\n          (t) => t.id === values.token\r\n        );\r\n\r\n        if (!selectedTokenInfo || values.amount === undefined) {\r\n          throw new Error(\"Invalid token or amount\");\r\n        }\r\n\r\n        const transaction = new Transaction();\r\n\r\n        if (values.token === \"sol\") {\r\n          transaction.add(\r\n            SystemProgram.transfer({\r\n              fromPubkey: publicKey,\r\n              toPubkey: destinationPubkey,\r\n              lamports: Math.floor(values.amount * LAMPORTS_PER_SOL),\r\n            })\r\n          );\r\n        } else if (selectedTokenInfo.mintAddress) {\r\n          const mintPubkey = new PublicKey(selectedTokenInfo.mintAddress);\r\n          const senderATA = await getAssociatedTokenAddress(\r\n            mintPubkey,\r\n            publicKey\r\n          );\r\n          const receiverATA = await getAssociatedTokenAddress(\r\n            mintPubkey,\r\n            destinationPubkey\r\n          );\r\n\r\n          transaction.add(\r\n            createTransferInstruction(\r\n              senderATA,\r\n              receiverATA,\r\n              publicKey,\r\n              Math.floor(\r\n                values.amount * Math.pow(10, selectedTokenInfo.decimals)\r\n              )\r\n            )\r\n          );\r\n        }\r\n\r\n        const { blockhash } = await connection.getLatestBlockhash();\r\n        transaction.recentBlockhash = blockhash;\r\n        transaction.feePayer = publicKey;\r\n\r\n        const signature = await sendTransaction(transaction, connection);\r\n\r\n        toast.message(\"Transaction sent\", {\r\n          description: \"Waiting for confirmation...\",\r\n        });\r\n\r\n        try {\r\n          let confirmed = false;\r\n          let retries = 0;\r\n          const maxRetries = 30;\r\n\r\n          while (!confirmed && retries < maxRetries) {\r\n            retries++;\r\n            await new Promise((resolve) => setTimeout(resolve, 1000));\r\n            const { value } = await connection.getSignatureStatus(signature);\r\n\r\n            if (\r\n              value?.confirmationStatus === \"confirmed\" ||\r\n              value?.confirmationStatus === \"finalized\"\r\n            ) {\r\n              confirmed = true;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (!confirmed) {\r\n            throw new Error(\r\n              \"Transaction confirmation timed out. Please check your wallet for status.\"\r\n            );\r\n          }\r\n        } catch (confirmError) {\r\n          console.error(\"Error confirming transaction:\", confirmError);\r\n          toast.warning(\"Transaction sent but confirmation failed\", {\r\n            description:\r\n              \"Your transaction was submitted but we couldn't confirm it. Please check your wallet for status.\",\r\n          });\r\n        }\r\n      }\r\n\r\n      toast.success(\"Transaction complete\", {\r\n        description: `Successfully sent ${values.amount} ${\r\n          selectedToken?.symbol || values.token\r\n        } to ${values.destination.slice(0, 6)}...${values.destination.slice(\r\n          -4\r\n        )}`,\r\n      });\r\n\r\n      if (publicKey) {\r\n        setIsUpdatingBalance(true);\r\n\r\n        setTimeout(async () => {\r\n          try {\r\n            const updatedTokens = await fetchTokenAccounts(publicKey);\r\n\r\n            setAvailableTokens((prevTokens) => {\r\n              return prevTokens.map((token) => {\r\n                const updatedToken = updatedTokens.find(\r\n                  (t) => t.id === token.id\r\n                );\r\n                if (updatedToken) {\r\n                  return { ...token, balance: updatedToken.balance };\r\n                }\r\n                return token;\r\n              });\r\n            });\r\n\r\n            if (selectedToken) {\r\n              const updatedToken = updatedTokens.find(\r\n                (t) => t.id === selectedToken.id\r\n              );\r\n              if (updatedToken) {\r\n                setSelectedToken((prev) =>\r\n                  prev ? { ...prev, balance: updatedToken.balance } : null\r\n                );\r\n              }\r\n            }\r\n\r\n            toast.message(\"Balance updated\", {\r\n              description: \"Your token balances have been refreshed\",\r\n            });\r\n          } catch (error) {\r\n            console.error(\"Error updating balances:\", error);\r\n          } finally {\r\n            setIsUpdatingBalance(false);\r\n          }\r\n        }, 2000);\r\n      }\r\n\r\n      const currentTokenValue = form.getValues(\"token\");\r\n      form.reset({\r\n        destination: \"\",\r\n        amount: undefined,\r\n        token: currentTokenValue,\r\n      });\r\n      setAmountValue(\"\");\r\n    } catch (error) {\r\n      console.error(\"Transaction error:\", error);\r\n      toast.error(\"Transaction failed\", {\r\n        description:\r\n          error instanceof Error ? error.message : \"Unknown error occurred\",\r\n      });\r\n    } finally {\r\n      setTimeout(() => {\r\n        setIsSubmitting(false);\r\n      }, 1000);\r\n    }\r\n  }\r\n\r\n  const handleTokenChange = (value: string) => {\r\n    const token = availableTokens.find((t) => t.id === value);\r\n    if (token) {\r\n      setSelectedToken(token);\r\n      form.setValue(\"token\", value);\r\n    }\r\n  };\r\n\r\n  const renderTokenItem = (token: TokenInfo) => (\r\n    <SelectItem key={token.id} value={token.id}>\r\n      <div className=\"flex items-center justify-between w-full\">\r\n        <div className=\"flex items-center\">\r\n          {token.icon && (\r\n            <div className=\"w-5 h-5 mr-2 rounded-full overflow-hidden flex items-center justify-center\">\r\n              <img\r\n                src={token.icon || \"/placeholder.svg\"}\r\n                alt={token.symbol}\r\n                className=\"w-4 h-4 object-contain\"\r\n                onError={(e) => {\r\n                  (e.target as HTMLImageElement).style.display = \"none\";\r\n                }}\r\n              />\r\n            </div>\r\n          )}\r\n          <span>{token.symbol}</span>\r\n        </div>\r\n        {showTokenBalance && (\r\n          <span className=\"text-muted-foreground ml-2 text-sm\">\r\n            {token.balance.toLocaleString(undefined, {\r\n              minimumFractionDigits: 0,\r\n              maximumFractionDigits: token.decimals > 6 ? 6 : token.decimals,\r\n            })}\r\n          </span>\r\n        )}\r\n      </div>\r\n    </SelectItem>\r\n  );\r\n\r\n  return (\r\n    <Card className={className}>\r\n      <CardHeader>\r\n        <CardTitle className=\"flex items-center\">\r\n          <Wallet className=\"h-5 w-5 mr-2\" />\r\n          Send Tokens\r\n        </CardTitle>\r\n      </CardHeader>\r\n      <CardContent>\r\n        <Form {...form}>\r\n          <form onSubmit={(e) => e.preventDefault()} className=\"space-y-6\">\r\n            <FormField\r\n              control={form.control}\r\n              name=\"destination\"\r\n              render={({ field }) => (\r\n                <FormItem className=\"flex flex-col\">\r\n                  <FormLabel>Destination Address</FormLabel>\r\n                  <FormControl>\r\n                    <Input\r\n                      placeholder=\"Enter wallet address\"\r\n                      {...field}\r\n                      disabled={!connected}\r\n                    />\r\n                  </FormControl>\r\n                  <FormMessage />\r\n                </FormItem>\r\n              )}\r\n            />\r\n\r\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\r\n              <FormField\r\n                control={form.control}\r\n                name=\"token\"\r\n                render={({ field }) => (\r\n                  <FormItem className=\"flex flex-col\">\r\n                    <FormLabel>Token</FormLabel>\r\n                    <Select\r\n                      onValueChange={handleTokenChange}\r\n                      defaultValue={field.value}\r\n                      disabled={!connected}\r\n                    >\r\n                      <FormControl>\r\n                        <SelectTrigger className=\"w-full min-w-[180px]\">\r\n                          <SelectValue\r\n                            placeholder={\r\n                              isLoadingTokens || isUpdatingBalance\r\n                                ? \"Loading tokens...\"\r\n                                : \"Select a token\"\r\n                            }\r\n                          />\r\n                        </SelectTrigger>\r\n                      </FormControl>\r\n                      <SelectContent>\r\n                        {isLoadingTokens || isUpdatingBalance ? (\r\n                          <div className=\"flex items-center justify-center p-2\">\r\n                            <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\r\n                            <span>\r\n                              {isUpdatingBalance\r\n                                ? \"Updating balances...\"\r\n                                : \"Loading tokens...\"}\r\n                            </span>\r\n                          </div>\r\n                        ) : availableTokens.length > 0 ? (\r\n                          <SelectGroup>\r\n                            {availableTokens.map(renderTokenItem)}\r\n                          </SelectGroup>\r\n                        ) : (\r\n                          <div className=\"p-2 text-muted-foreground text-center\">\r\n                            No tokens found\r\n                          </div>\r\n                        )}\r\n                      </SelectContent>\r\n                    </Select>\r\n                    <FormMessage />\r\n                  </FormItem>\r\n                )}\r\n              />\r\n\r\n              <FormField\r\n                control={form.control}\r\n                name=\"amount\"\r\n                render={({ field }) => (\r\n                  <FormItem className=\"flex flex-col\">\r\n                    <div className=\"flex justify-between items-center\">\r\n                      <FormLabel>Amount</FormLabel>\r\n                    </div>\r\n                    <FormControl>\r\n                      <Input\r\n                        type=\"number\"\r\n                        placeholder=\"0.0\"\r\n                        step=\"any\"\r\n                        value={amountValue}\r\n                        onChange={(e) => {\r\n                          setAmountValue(e.target.value);\r\n                          field.onChange(\r\n                            e.target.value === \"\"\r\n                              ? undefined\r\n                              : Number.parseFloat(e.target.value)\r\n                          );\r\n                        }}\r\n                        disabled={!connected}\r\n                      />\r\n                    </FormControl>\r\n                    {selectedToken && showTokenBalance && (\r\n                      <p className=\"text-xs text-muted-foreground mt-1\">\r\n                        Available:{\" \"}\r\n                        {selectedToken.balance.toLocaleString(undefined, {\r\n                          minimumFractionDigits: 0,\r\n                          maximumFractionDigits:\r\n                            selectedToken.decimals > 6\r\n                              ? 6\r\n                              : selectedToken.decimals,\r\n                        })}{\" \"}\r\n                        {selectedToken.symbol}\r\n                      </p>\r\n                    )}\r\n                    <FormMessage />\r\n                  </FormItem>\r\n                )}\r\n              />\r\n            </div>\r\n\r\n            {connected ? (\r\n              <Button\r\n                type=\"button\"\r\n                onClick={() => form.handleSubmit(handleSubmit)()}\r\n                className=\"w-full\"\r\n                disabled={isSubmitting || isLoading || isLoadingTokens}\r\n              >\r\n                {isSubmitting ? (\r\n                  <>\r\n                    <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\r\n                    Processing Transaction...\r\n                  </>\r\n                ) : (\r\n                  <>\r\n                    Send Tokens\r\n                    <ArrowRight className=\"ml-2 h-4 w-4\" />\r\n                  </>\r\n                )}\r\n              </Button>\r\n            ) : (\r\n              <ConnectWalletButton className=\"w-full\">\r\n                Connect Wallet\r\n              </ConnectWalletButton>\r\n            )}\r\n\r\n            {connected && (\r\n              <div className=\"pt-4 border-t\">\r\n                <div className=\"flex items-center justify-between text-sm text-muted-foreground\">\r\n                  <span>Network</span>\r\n                  <span className=\"font-medium bg-muted px-2 py-1 rounded\">\r\n                    {networkName}\r\n                  </span>\r\n                </div>\r\n              </div>\r\n            )}\r\n          </form>\r\n        </Form>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "components/ui/murphy/send-token-form.tsx"
    }
  ]
}