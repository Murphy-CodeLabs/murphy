{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "swap-token-form",
  "type": "registry:block",
  "title": "Swap Token Form",
  "description": "A simple swap token form component.",
  "dependencies": [
    "@solana/web3.js",
    "@solana/spl-token",
    "@solana/wallet-adapter-react",
    "@coral-xyz/anchor"
  ],
  "registryDependencies": [
    "input",
    "button",
    "form",
    "card",
    "sonner",
    "select",
    "dialog",
    "dropdown-menu",
    "slider"
  ],
  "files": [
    {
      "path": "components/ui/murphy/swap-token-form.tsx",
      "content": "\"use client\";\r\n\r\nimport { useState, useEffect, useMemo, useContext } from \"react\";\r\nimport { useForm } from \"react-hook-form\";\r\nimport { toast } from \"sonner\";\r\nimport { ArrowDown, Loader2, RefreshCw, Settings } from \"lucide-react\";\r\nimport {\r\n  PublicKey,\r\n  Transaction,\r\n  LAMPORTS_PER_SOL,\r\n} from \"@solana/web3.js\";\r\nimport { useWallet, useConnection } from \"@solana/wallet-adapter-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport {\r\n  Form,\r\n  FormControl,\r\n  FormField,\r\n  FormItem,\r\n  FormLabel,\r\n  FormMessage,\r\n} from \"@/components/ui/form\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n  SelectGroup,\r\n} from \"@/components/ui/select\";\r\nimport { ConnectWalletButton } from \"./connect-wallet-button\";\r\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from \"@/components/ui/popover\";\r\nimport { Slider } from \"@/components/ui/slider\";\r\nimport { useJupiterTrade } from \"@/hook/murphy/use-JupiterTrade\";\r\nimport { ModalContext } from \"@/components/providers/wallet-provider\";\r\n\r\ndeclare global {\r\n  interface Window {\r\n    quoteTimeout: NodeJS.Timeout | null;\r\n  }\r\n}\r\n\r\n// Token info type\r\nexport type TokenInfo = {\r\n  id: string;\r\n  symbol: string;\r\n  name: string;\r\n  balance: number;\r\n  decimals: number;\r\n  mintAddress?: string;\r\n  icon?: string;\r\n};\r\n\r\n// Quote result interface - must match the result from Jupiter API\r\ninterface QuoteResult {\r\n  outputAmount: string;    // Amount of tokens received\r\n  exchangeRate: number;    // Exchange rate\r\n  priceImpactPct: number;  // Price impact (%)\r\n  routeInfo: any;          // Route information\r\n}\r\n\r\n// Type for swap form values\r\ntype SwapFormValues = {\r\n  tokenIn: string;\r\n  tokenOut: string;\r\n  amountIn: number | undefined;\r\n  amountOut: number | undefined;\r\n  slippage: number;\r\n};\r\n\r\n// Create custom resolver for form\r\nconst customResolver = (data: any) => {\r\n  const errors: any = {};\r\n\r\n  // Validate token input\r\n  if (!data.tokenIn) {\r\n    errors.tokenIn = {\r\n      type: \"required\",\r\n      message: \"Please select an input token\",\r\n    };\r\n  }\r\n\r\n  // Validate token output\r\n  if (!data.tokenOut) {\r\n    errors.tokenOut = {\r\n      type: \"required\",\r\n      message: \"Please select an output token\",\r\n    };\r\n  }\r\n\r\n  // Validate amount\r\n  if (data.amountIn === undefined || data.amountIn === null || data.amountIn === \"\") {\r\n    errors.amountIn = {\r\n      type: \"required\",\r\n      message: \"Amount is required\",\r\n    };\r\n  } else if (Number(data.amountIn) <= 0) {\r\n    errors.amountIn = {\r\n      type: \"min\",\r\n      message: \"Amount must be greater than 0\",\r\n    };\r\n  }\r\n\r\n  return {\r\n    values: Object.keys(errors).length === 0 ? data : {},\r\n    errors,\r\n  };\r\n};\r\n\r\n// Props interface\r\nexport interface SwapFormProps {\r\n  onSwap?: (values: SwapFormValues) => Promise<void>;\r\n  tokens?: TokenInfo[];\r\n  isLoading?: boolean;\r\n  showTokenBalance?: boolean;\r\n  className?: string;\r\n}\r\n\r\nexport function SwapForm({\r\n  onSwap,\r\n  tokens,\r\n  isLoading = false,\r\n  showTokenBalance = true,\r\n  className,\r\n}: SwapFormProps) {\r\n  // State variables\r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n  const [selectedTokenIn, setSelectedTokenIn] = useState<TokenInfo | null>(null);\r\n  const [selectedTokenOut, setSelectedTokenOut] = useState<TokenInfo | null>(null);\r\n  const [isLoadingTokens, setIsLoadingTokens] = useState(false);\r\n  const [isUpdatingBalance, setIsUpdatingBalance] = useState(false);\r\n  const [isLoadingQuote, setIsLoadingQuote] = useState(false);\r\n  const [quoteResult, setQuoteResult] = useState<QuoteResult | null>(null);\r\n  const [amountInValue, setAmountInValue] = useState<string>(\"\");\r\n  const [amountOutValue, setAmountOutValue] = useState<string>(\"\");\r\n  const [slippageValue, setSlippageValue] = useState<number>(0.5); // 0.5% default\r\n  const [slippageSettingsOpen, setSlippageSettingsOpen] = useState(false);\r\n  \r\n  const { publicKey, connected, sendTransaction, wallet } = useWallet();\r\n  const { connection } = useConnection();\r\n  const { executeTrade, getQuote } = useJupiterTrade();\r\n  const { endpoint } = useContext(ModalContext);\r\n\r\n  // Form setup with react-hook-form\r\n  const form = useForm<SwapFormValues>({\r\n    defaultValues: {\r\n      tokenIn: \"\",\r\n      tokenOut: \"\",\r\n      amountIn: undefined,\r\n      amountOut: undefined,\r\n      slippage: 0.5,\r\n    },\r\n    mode: \"onSubmit\",  // Only validate on submit\r\n    resolver: customResolver,  // Use our custom resolver\r\n  });\r\n\r\n  // Available tokens state\r\n  const [availableTokens, setAvailableTokens] = useState<TokenInfo[]>([]);\r\n\r\n  // Add state to store timeout\r\n  const [inputTimeout, setInputTimeout] = useState<NodeJS.Timeout | null>(null);\r\n\r\n  // Clear timeout when component unmounts\r\n  useEffect(() => {\r\n    return () => {\r\n      if (inputTimeout) {\r\n        clearTimeout(inputTimeout);\r\n      }\r\n    };\r\n  }, [inputTimeout]);\r\n\r\n  // Determine network from connection endpoint\r\n  const networkName = useMemo(() => {\r\n    if (!connection) return \"Unknown\";\r\n\r\n    const endpoint = connection.rpcEndpoint;\r\n\r\n    if (endpoint.includes(\"devnet\")) return \"Devnet\";\r\n    if (endpoint.includes(\"testnet\")) return \"Testnet\";\r\n    if (endpoint.includes(\"mainnet\")) return \"Mainnet\";\r\n    if (endpoint.includes(\"localhost\") || endpoint.includes(\"127.0.0.1\"))\r\n      return \"Localnet\";\r\n\r\n    // Custom endpoint - show partial URL\r\n    const url = new URL(endpoint);\r\n    return url.hostname;\r\n  }, [connection]);\r\n\r\n  // Fetch token accounts from wallet\r\n  const fetchTokenAccounts = async (ownerPublicKey: PublicKey) => {\r\n    try {\r\n      setIsLoadingTokens(true);\r\n\r\n      // Get SOL balance\r\n      let solBalance = 0;\r\n      try {\r\n        if(!connection){\r\n          throw new Error(\"No connection available\");\r\n        }\r\n        solBalance = (await connection.getBalance(ownerPublicKey)) / LAMPORTS_PER_SOL;\r\n\r\n        let retryCount = 0;\r\n        const maxRetries = 3;\r\n\r\n        while (retryCount < maxRetries) {\r\n          try {\r\n            solBalance = (await\r\n              connection.getBalance(ownerPublicKey)) / LAMPORTS_PER_SOL;\r\n              break;\r\n            } catch (error: any) {\r\n              retryCount++;\r\n              if (retryCount === maxRetries) {\r\n                throw error;\r\n              }\r\n\r\n              await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for 1 second before retrying\r\n            }\r\n          }\r\n      } catch (error: any) {\r\n        console.error(\"Error fetching SOL balance:\", error);\r\n        toast.error(\"Failed to fetch SOL balance\", {\r\n          description: error?.message || \"Please check your wallet connection\",\r\n        })\r\n      }\r\n\r\n      // Extended default tokens list\r\n      const defaultTokens: TokenInfo[] = [\r\n        {\r\n          id: \"sol\",\r\n          symbol: \"SOL\",\r\n          name: \"Solana\",\r\n          balance: solBalance,\r\n          decimals: 9,\r\n          mintAddress: \"So11111111111111111111111111111111111111112\",\r\n          icon: \"/crypto-logos/solana-logo.svg\",\r\n        },\r\n        {\r\n          id: \"usdc\",\r\n          symbol: \"USDC\",\r\n          name: \"USD Coin\",\r\n          balance: 0,\r\n          decimals: 6,\r\n          mintAddress: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\r\n          icon: \"/crypto-logos/usd-coin-usdc-logo.svg\",\r\n        },\r\n        {\r\n          id: \"usdt\",\r\n          symbol: \"USDT\",\r\n          name: \"Tether USD\",\r\n          balance: 0,\r\n          decimals: 6,\r\n          mintAddress: \"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB\",\r\n          icon: \"/crypto-logos/tether-usdt-logo.svg\",\r\n        }\r\n      ];\r\n\r\n      // Fetch SPL tokens using the provider connection\r\n      const splTokens: TokenInfo[] = [];\r\n\r\n      try {\r\n        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(\r\n          ownerPublicKey,\r\n          {\r\n            programId: new PublicKey(\r\n              \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\r\n            ),\r\n          }\r\n        );\r\n\r\n        for (const account of tokenAccounts.value) {\r\n          const accountData = account.account.data.parsed.info;\r\n          const mintAddress = accountData.mint;\r\n          const tokenAmount = accountData.tokenAmount;\r\n\r\n          if (tokenAmount.uiAmount > 0) {\r\n            // Only include tokens with non-zero balance\r\n            splTokens.push({\r\n              id: mintAddress,\r\n              symbol: mintAddress.substring(0, 4) + \"...\", // Use shortened mint as symbol if no metadata\r\n              name: \"Token \" + mintAddress.substring(0, 6), // Use shortened mint as name if no metadata\r\n              balance: tokenAmount.uiAmount,\r\n              decimals: tokenAmount.decimals,\r\n              mintAddress: mintAddress,\r\n            });\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Error fetching SPL token accounts:\", error);\r\n      }\r\n\r\n      // Return combined tokens\r\n      return [...defaultTokens, ...splTokens];\r\n    } catch (error) {\r\n      console.error(\"Error fetching token accounts:\", error);\r\n      // Return basic SOL token on error\r\n      return [\r\n        {\r\n          id: \"sol\",\r\n          symbol: \"SOL\",\r\n          name: \"Solana\",\r\n          balance: 0,\r\n          decimals: 9,\r\n          icon: \"/crypto-logos/solana-logo.svg\",\r\n        },\r\n      ];\r\n    } finally {\r\n      setIsLoadingTokens(false);\r\n    }\r\n  };\r\n\r\n  // Load tokens effect\r\n  useEffect(() => {\r\n    // If tokens are provided as props, use those\r\n    if (tokens) {\r\n      setAvailableTokens(tokens);\r\n    }\r\n    // Otherwise, if wallet is connected, fetch tokens\r\n    else if (connected && publicKey) {\r\n      fetchTokenAccounts(publicKey)\r\n        .then((fetchedTokens) => {\r\n          setAvailableTokens(fetchedTokens);\r\n        })\r\n        .catch((error) => {\r\n          console.error(\"Error setting tokens:\", error);\r\n          // Set default SOL token on error\r\n          setAvailableTokens([\r\n            {\r\n              id: \"sol\",\r\n              symbol: \"SOL\",\r\n              name: \"Solana\",\r\n              balance: 0,\r\n              decimals: 9,\r\n              icon: \"/crypto-logos/solana-logo.svg\",\r\n            },\r\n          ]);\r\n        });\r\n    }\r\n  }, [tokens, connected, publicKey]);\r\n\r\n  // Handle use max amount\r\n  const handleUseMax = (e?: React.MouseEvent) => {\r\n    // Prevent form submit event if there is an event\r\n    if (e) {\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n    }\r\n    \r\n    if (selectedTokenIn && selectedTokenIn.balance > 0) {\r\n      // If SOL is selected, keep 0.01 SOL for transaction fees\r\n      let maxAmount: number;\r\n      \r\n      if (selectedTokenIn.id === \"sol\" || \r\n          selectedTokenIn.mintAddress === \"So11111111111111111111111111111111111111112\") {\r\n        // Keep 0.05 SOL for transaction fees, enough for most transactions\r\n        maxAmount = Math.max(selectedTokenIn.balance - 0.05, 0);\r\n      } else {\r\n        maxAmount = selectedTokenIn.balance;\r\n      }\r\n      \r\n      setAmountInValue(maxAmount.toString());\r\n      form.setValue(\"amountIn\", maxAmount, {\r\n        shouldValidate: false,\r\n        shouldDirty: true,\r\n        shouldTouch: true,\r\n      });\r\n      \r\n      // If the output token is selected, wait a bit before getting the quote\r\n      if (selectedTokenOut && maxAmount > 0) {\r\n        setTimeout(() => {\r\n          fetchSwapQuote(maxAmount, true);\r\n        }, 0);\r\n      }\r\n    }\r\n  };\r\n\r\n  // Handle amount input change with debounce\r\n  const handleAmountInChange = (value: string) => {\r\n    setAmountInValue(value);\r\n    const parsedValue = value === \"\" ? undefined : parseFloat(value);\r\n    form.setValue(\"amountIn\", parsedValue, {\r\n      shouldValidate: false  // Prevent validation\r\n    });\r\n    \r\n    if (!parsedValue || parsedValue <= 0) {\r\n      setAmountOutValue(\"\");\r\n      setQuoteResult(null);\r\n      return;\r\n    }\r\n\r\n    // Cancel old timeout if any\r\n    if (inputTimeout) {\r\n      clearTimeout(inputTimeout);\r\n    }\r\n    \r\n    // Automatically update the quote after the user stops typing for 500ms\r\n    if (parsedValue && parsedValue > 0 && selectedTokenIn && selectedTokenOut) {\r\n      const newTimeout = setTimeout(() => {\r\n        fetchSwapQuote(parsedValue, false);\r\n      }, 500);\r\n      \r\n      setInputTimeout(newTimeout);\r\n    }\r\n  };\r\n\r\n  // Add blur event handler to ensure update when user loses focus\r\n  const handleAmountInBlur = () => {\r\n    if (amountInValue && parseFloat(amountInValue) > 0 && selectedTokenIn && selectedTokenOut) {\r\n      fetchSwapQuote(parseFloat(amountInValue), false);\r\n    }\r\n  };\r\n\r\n  // Handle token change\r\n  const handleTokenChange = (isInput: boolean, tokenId: string) => {\r\n    const token = availableTokens.find((t) => t.id === tokenId);\r\n    \r\n    if (!token) return;\r\n    \r\n    if (isInput) {\r\n      if (selectedTokenOut && token.id === selectedTokenOut.id) {\r\n        toast.error(\"Cannot select the same token\", {\r\n          description: \"Please select different tokens for input and output\",\r\n        });\r\n        return;\r\n      }\r\n      \r\n      setSelectedTokenIn(token);\r\n      form.setValue(\"tokenIn\", token.id, {\r\n        shouldValidate: false  // Prevent validation\r\n      });\r\n    } else {\r\n      if (selectedTokenIn && token.id === selectedTokenIn.id) {\r\n        toast.error(\"Cannot select the same token\", {\r\n          description: \"Please select different tokens for input and output\",\r\n        });\r\n        return;\r\n      }\r\n      \r\n      setSelectedTokenOut(token);\r\n      form.setValue(\"tokenOut\", token.id, {\r\n        shouldValidate: false  // Prevent validation\r\n      });\r\n    }\r\n    \r\n    // Clear amounts and re-quote if we have an input amount\r\n    if (amountInValue && parseFloat(amountInValue) > 0) {\r\n      fetchSwapQuote(parseFloat(amountInValue), false);\r\n    }\r\n  };\r\n\r\n  // Handle slippage change\r\n  const handleSlippageChange = (value: number) => {\r\n    setSlippageValue(value);\r\n    form.setValue(\"slippage\", value, {\r\n      shouldValidate: false  // Prevent validation\r\n    });\r\n  };\r\n\r\n  // Switch tokens\r\n  const handleSwitchTokens = () => {\r\n    // Swap token selections\r\n    const tempTokenIn = selectedTokenIn;\r\n    const tempTokenOut = selectedTokenOut;\r\n    \r\n    setSelectedTokenIn(tempTokenOut);\r\n    setSelectedTokenOut(tempTokenIn);\r\n    \r\n    if (tempTokenOut) {\r\n      form.setValue(\"tokenIn\", tempTokenOut.id, {\r\n        shouldValidate: false  // Prevent validation\r\n      });\r\n    }\r\n    \r\n    if (tempTokenIn) {\r\n      form.setValue(\"tokenOut\", tempTokenIn.id, {\r\n        shouldValidate: false  // Prevent validation\r\n      });\r\n    }\r\n    \r\n    // Clear amounts and re-quote if needed\r\n    setAmountInValue(\"\");\r\n    setAmountOutValue(\"\");\r\n    form.setValue(\"amountIn\", undefined, {\r\n      shouldValidate: false  // Prevent validation\r\n    });\r\n    form.setValue(\"amountOut\", undefined, {\r\n      shouldValidate: false  // Prevent validation\r\n    });\r\n    setQuoteResult(null);\r\n  };\r\n\r\n  // Fetch swap quote\r\n  const fetchSwapQuote = async (amount: number, isFromMaxButton: boolean = false) => {\r\n    if (!connected || !publicKey) {\r\n      toast.error(\"Wallet not connected\", { \r\n        description: \"Please connect your wallet to get a quote\" \r\n      });\r\n      return;\r\n    }\r\n  \r\n    if (!selectedTokenIn || !selectedTokenOut) {\r\n      toast.error(\"Select tokens\", { \r\n        description: \"Please select input and output tokens\" \r\n      });\r\n      return;\r\n    }\r\n  \r\n    if (amount <= 0) {\r\n      setAmountOutValue(\"\");\r\n      setQuoteResult(null);\r\n      return;\r\n    }\r\n  \r\n    try {\r\n      setIsLoadingQuote(true);\r\n  \r\n      // Check token address\r\n      if (!selectedTokenIn.mintAddress || !selectedTokenOut.mintAddress) {\r\n        throw new Error(\"Token mintAddress not found\");\r\n      }\r\n\r\n      // Create PublicKey from address\r\n      const inputMint = new PublicKey(selectedTokenIn.mintAddress);\r\n      const outputMint = new PublicKey(selectedTokenOut.mintAddress);\r\n      const slippageBps = Math.floor(slippageValue * 100);\r\n      \r\n      // Call API to get quote\r\n      const quoteResponse = await getQuote(\r\n        outputMint,\r\n        amount,\r\n        inputMint,\r\n        slippageBps\r\n      );\r\n  \r\n      if (quoteResponse) {\r\n        // Update state with result from API\r\n        setQuoteResult(quoteResponse);\r\n        setAmountOutValue(quoteResponse.outputAmount);\r\n        form.setValue(\"amountOut\", Number(quoteResponse.outputAmount), {\r\n          shouldValidate: false\r\n        });\r\n      } else {\r\n        setQuoteResult(null);\r\n        setAmountOutValue(\"\");\r\n        form.setValue(\"amountOut\", undefined, {\r\n          shouldValidate: false\r\n        });\r\n      }\r\n    } catch (error: any) {\r\n      setQuoteResult(null);\r\n      setAmountOutValue(\"\");\r\n      toast.error(\"Failed to get quote\", {\r\n        description: error?.message || \"Unable to fetch quote from Jupiter\"\r\n      });\r\n    } finally {\r\n      setIsLoadingQuote(false);\r\n    }\r\n  };\r\n\r\n  // Handle form submission\r\n  const onSubmit = async (values: SwapFormValues) => {\r\n    if (!connected) {\r\n      toast.error(\"Wallet not connected\");\r\n      return;\r\n    }\r\n\r\n    if (!publicKey) {\r\n      toast.error(\"Public key not found\");\r\n      return;\r\n    }\r\n\r\n    if (!connection) {\r\n      toast.error(\"Invalid connection\");\r\n      return;\r\n    }\r\n\r\n    if (!endpoint) {\r\n      toast.error(\"RPC endpoint not found\");\r\n      return;\r\n    }\r\n\r\n    if (!selectedTokenIn || !selectedTokenOut) {\r\n      toast.error(\"Select tokens\");\r\n      return;\r\n    }\r\n\r\n    if (!values.amountIn || values.amountIn <= 0) {\r\n      toast.error(\"Invalid amount\");\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsSubmitting(true);\r\n      \r\n      // Check token address\r\n      if (!selectedTokenIn.mintAddress || !selectedTokenOut.mintAddress) {\r\n        throw new Error(\"Token mintAddress not found\");\r\n      }\r\n      \r\n      // Create PublicKey from address\r\n      const inputMint = new PublicKey(selectedTokenIn.mintAddress);\r\n      const outputMint = new PublicKey(selectedTokenOut.mintAddress);\r\n      const slippageBps = Math.floor(slippageValue * 100);\r\n      \r\n      // Log transaction information for debugging\r\n      console.log(\"=== Transaction Information ===\");\r\n      console.log(\"Endpoint:\", endpoint);\r\n      console.log(\"Input token:\", selectedTokenIn.symbol, inputMint.toString());\r\n      console.log(\"Output token:\", selectedTokenOut.symbol, outputMint.toString());\r\n      console.log(\"Amount:\", values.amountIn);\r\n      console.log(\"Slippage:\", slippageBps, \"bps\");\r\n      console.log(\"Wallet connected:\", connected ? \"Yes\" : \"No\");\r\n      console.log(\"PublicKey:\", publicKey.toString());\r\n      console.log(\"========================\");\r\n      \r\n      // Check all parameters before executing the transaction\r\n      if (!wallet) {\r\n        throw new Error(\"Wallet not connected\");\r\n      }\r\n      \r\n      try {\r\n        // Execute the swap transaction with proper validation\r\n        console.log(\"Calling executeTrade with parameters:\");\r\n        console.log(\" - outputMint:\", outputMint.toString());\r\n        console.log(\" - inputAmount:\", values.amountIn);\r\n        console.log(\" - inputMint:\", inputMint.toString());\r\n        console.log(\" - slippageBps:\", slippageBps);\r\n        console.log(\" - wallet:\", typeof wallet, wallet ? \"connected\" : \"not connected\");\r\n        \r\n        // Check if wallet supports signTransaction method\r\n        const walletAdapter = wallet as any;\r\n        console.log(\" - wallet supports signTransaction:\", walletAdapter?.signTransaction ? \"yes\" : \"no\");\r\n        console.log(\" - endpoint:\", endpoint);\r\n\r\n        // Pass fewer parameters, compatible with new API\r\n        const signature = await executeTrade(\r\n          outputMint,\r\n          values.amountIn,\r\n          inputMint,\r\n          slippageBps\r\n        );\r\n  \r\n        toast.success(\"Swap successful!\", {\r\n          description: `Transaction: ${signature}`\r\n        });\r\n  \r\n        // Reset form and update balances\r\n        setAmountInValue(\"\");\r\n        setAmountOutValue(\"\");\r\n        form.setValue(\"amountIn\", undefined, {\r\n          shouldValidate: false\r\n        });\r\n        form.setValue(\"amountOut\", undefined, {\r\n          shouldValidate: false\r\n        });\r\n        setQuoteResult(null);\r\n  \r\n        // Update balances after successful swap\r\n        if (publicKey) {\r\n          await updateBalances();\r\n        }\r\n      } catch (tradeError: any) {\r\n        console.error(\"Trade execution error:\", tradeError);\r\n        toast.error(\"Transaction failed\", {\r\n          description: tradeError.message || \"Unable to execute transaction\"\r\n        });\r\n      }\r\n    } catch (error: any) {\r\n      console.error(\"Swap error:\", error);\r\n      toast.error(\"Swap failed\", {\r\n        description: error.message || \"Transaction failed\"\r\n      });\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  };\r\n\r\n  // Separate function to update balances\r\n  const updateSelectedTokenBalances = (updatedTokens: TokenInfo[]) => {\r\n    // Update selected token balances if they exist in the updated tokens list\r\n    if (selectedTokenIn) {\r\n      const updatedTokenIn = updatedTokens.find(t => t.id === selectedTokenIn.id);\r\n      if (updatedTokenIn) {\r\n        setSelectedTokenIn(updatedTokenIn);\r\n      }\r\n    }\r\n    \r\n    if (selectedTokenOut) {\r\n      const updatedTokenOut = updatedTokens.find(t => t.id === selectedTokenOut.id);\r\n      if (updatedTokenOut) {\r\n        setSelectedTokenOut(updatedTokenOut);\r\n      }\r\n    }\r\n  };\r\n\r\n  // Existing updateBalances function remains the same\r\n  const updateBalances = async () => {\r\n    setIsUpdatingBalance(true);\r\n    try {\r\n      const updatedTokens = await fetchTokenAccounts(publicKey!);\r\n      setAvailableTokens(updatedTokens);\r\n      updateSelectedTokenBalances(updatedTokens);\r\n      toast.success(\"Balances updated\");\r\n    } catch (error) {\r\n      console.error(\"Error updating balances:\", error);\r\n    } finally {\r\n      setIsUpdatingBalance(false);\r\n    }\r\n  };\r\n\r\n  // Render token item for the select dropdown\r\n  const renderTokenItem = (token: TokenInfo) => (\r\n    <SelectItem key={token.id} value={token.id}>\r\n      <div className=\"flex items-center justify-between w-full\">\r\n        <div className=\"flex items-center\">\r\n          {token.icon && (\r\n            <div className=\"w-5 h-5 mr-2 rounded-full overflow-hidden flex items-center justify-center\">\r\n              <img\r\n                src={token.icon || \"/placeholder.svg\"}\r\n                alt={token.symbol}\r\n                className=\"w-4 h-4 object-contain\"\r\n                onError={(e) => {\r\n                  (e.target as HTMLImageElement).style.display = \"none\";\r\n                }}\r\n              />\r\n            </div>\r\n          )}\r\n          <span>{token.symbol}</span>\r\n        </div>\r\n        {showTokenBalance && (\r\n          <span className=\"text-muted-foreground ml-2 text-sm\">\r\n            {token.balance.toLocaleString(undefined, {\r\n              minimumFractionDigits: 0,\r\n              maximumFractionDigits: token.decimals > 6 ? 6 : token.decimals,\r\n            })}\r\n          </span>\r\n        )}\r\n      </div>\r\n    </SelectItem>\r\n  );\r\n\r\n  return (\r\n    <Card className={className}>\r\n      <CardHeader>\r\n        <CardTitle className=\"flex items-center justify-between\">\r\n          <span>Swap Tokens</span>\r\n          <Popover open={slippageSettingsOpen} onOpenChange={setSlippageSettingsOpen}>\r\n            <PopoverTrigger asChild>\r\n              <Button variant=\"ghost\" size=\"icon\">\r\n                <Settings className=\"h-5 w-5\" />\r\n              </Button>\r\n            </PopoverTrigger>\r\n            <PopoverContent className=\"w-80\">\r\n              <div className=\"space-y-4\">\r\n                <h4 className=\"font-medium\">Slippage Tolerance</h4>\r\n                <div className=\"flex items-center justify-between gap-2\">\r\n                  <Button \r\n                    variant={slippageValue === 0.1 ? \"default\" : \"outline\"} \r\n                    size=\"sm\"\r\n                    onClick={() => handleSlippageChange(0.1)}\r\n                    className=\"flex-1\"\r\n                  >\r\n                    0.1%\r\n                  </Button>\r\n                  <Button \r\n                    variant={slippageValue === 0.5 ? \"default\" : \"outline\"} \r\n                    size=\"sm\"\r\n                    onClick={() => handleSlippageChange(0.5)}\r\n                    className=\"flex-1\"\r\n                  >\r\n                    0.5%\r\n                  </Button>\r\n                  <Button \r\n                    variant={slippageValue === 1 ? \"default\" : \"outline\"} \r\n                    size=\"sm\"\r\n                    onClick={() => handleSlippageChange(1)}\r\n                    className=\"flex-1\"\r\n                  >\r\n                    1.0%\r\n                  </Button>\r\n                </div>\r\n                <div className=\"space-y-2\">\r\n                  <div className=\"flex justify-between\">\r\n                    <span>Custom: {slippageValue.toFixed(1)}%</span>\r\n                  </div>\r\n                  <Slider\r\n                    value={[slippageValue]}\r\n                    min={0.1}\r\n                    max={5}\r\n                    step={0.1}\r\n                    onValueChange={(value) => handleSlippageChange(value[0])}\r\n                  />\r\n                  {slippageValue > 3 && (\r\n                    <p className=\"text-yellow-500 text-sm\">\r\n                      High slippage increases the risk of price impact\r\n                    </p>\r\n                  )}\r\n                </div>\r\n              </div>\r\n            </PopoverContent>\r\n          </Popover>\r\n        </CardTitle>\r\n      </CardHeader>\r\n      <CardContent>\r\n        <Form {...form}>\r\n          <form \r\n            onSubmit={(e) => {\r\n              // Check if clicking MAX button then do not submit\r\n              const target = e.target as HTMLElement;\r\n              const maxButton = target.querySelector('.max-button');\r\n              if (maxButton && (maxButton === document.activeElement || maxButton.contains(document.activeElement as Node))) {\r\n                e.preventDefault();\r\n                return;\r\n              }\r\n              \r\n              e.preventDefault();\r\n              form.handleSubmit(onSubmit)(e);\r\n            }}\r\n            className=\"space-y-4\"\r\n          >\r\n            {/* Token Input Field */}\r\n            <div className=\"space-y-2\">\r\n              <FormField\r\n                control={form.control}\r\n                name=\"tokenIn\"\r\n                render={({ field }) => (\r\n                  <FormItem className=\"bg-secondary/50 rounded-lg p-4\">\r\n                    <div className=\"flex justify-between items-center\">\r\n                      <FormLabel>You Pay</FormLabel>\r\n                      {selectedTokenIn && showTokenBalance && (\r\n                        <div className=\"flex items-center text-xs text-muted-foreground space-x-1\">\r\n                          <span>\r\n                            Balance: {selectedTokenIn.balance.toLocaleString(undefined, {\r\n                              minimumFractionDigits: 0,\r\n                              maximumFractionDigits: selectedTokenIn.decimals > 6 ? 6 : selectedTokenIn.decimals,\r\n                            })}\r\n                          </span>\r\n                          <div className=\"max-button-container\" onClick={(e) => e.stopPropagation()}>\r\n                            <span \r\n                              className=\"cursor-pointer h-auto py-0 px-2 text-xs text-primary hover:underline max-button\" \r\n                              onClick={(e) => {\r\n                                e.preventDefault();\r\n                                e.stopPropagation();\r\n                                handleUseMax();\r\n                              }}\r\n                            >\r\n                              MAX\r\n                            </span>\r\n                          </div>\r\n                        </div>\r\n                      )}\r\n                    </div>\r\n                    <div className=\"flex items-center space-x-2 mt-2\">\r\n                      <FormControl>\r\n                        <Input\r\n                          type=\"number\"\r\n                          placeholder=\"0.0\"\r\n                          step=\"any\"\r\n                          value={amountInValue}\r\n                          onChange={(e) => handleAmountInChange(e.target.value)}\r\n                          onBlur={handleAmountInBlur}\r\n                          disabled={!connected || !selectedTokenIn}\r\n                          className=\"bg-transparent border-none text-xl font-medium placeholder:text-muted-foreground focus-visible:ring-0 focus-visible:ring-offset-0\"\r\n                        />\r\n                      </FormControl>\r\n                      <Select\r\n                        onValueChange={(value) => handleTokenChange(true, value)}\r\n                        value={field.value}\r\n                        disabled={!connected}\r\n                      >\r\n                        <FormControl>\r\n                          <SelectTrigger className=\"min-w-[140px] h-auto bg-background\">\r\n                            <SelectValue\r\n                              placeholder={\r\n                                isLoadingTokens || isUpdatingBalance\r\n                                  ? \"Loading...\"\r\n                                  : \"Select\"\r\n                              }\r\n                            >\r\n                              {selectedTokenIn && (\r\n                                <div className=\"flex items-center\">\r\n                                  {selectedTokenIn.icon && (\r\n                                    <img\r\n                                      src={selectedTokenIn.icon}\r\n                                      alt={selectedTokenIn.symbol}\r\n                                      className=\"w-5 h-5 mr-2 rounded-full\"\r\n                                    />\r\n                                  )}\r\n                                  {selectedTokenIn.symbol}\r\n                                </div>\r\n                              )}\r\n                            </SelectValue>\r\n                          </SelectTrigger>\r\n                        </FormControl>\r\n                        <SelectContent>\r\n                          {isLoadingTokens || isUpdatingBalance ? (\r\n                            <div className=\"flex items-center justify-center p-2\">\r\n                              <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\r\n                              <span>\r\n                                {isUpdatingBalance\r\n                                  ? \"Updating balances...\"\r\n                                  : \"Loading tokens...\"}\r\n                              </span>\r\n                            </div>\r\n                          ) : availableTokens.length > 0 ? (\r\n                            <SelectGroup>\r\n                              {availableTokens.map(renderTokenItem)}\r\n                            </SelectGroup>\r\n                          ) : (\r\n                            <div className=\"p-2 text-muted-foreground text-center\">\r\n                              No tokens found\r\n                            </div>\r\n                          )}\r\n                        </SelectContent>\r\n                      </Select>\r\n                    </div>\r\n                    <FormMessage />\r\n                  </FormItem>\r\n                )}\r\n              />\r\n              \r\n              {/* Arrow button to switch tokens */}\r\n              <div className=\"flex justify-center -my-2 relative z-10\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"icon\"\r\n                  className=\"rounded-full h-10 w-10 bg-background border-background shadow-md\"\r\n                  onClick={handleSwitchTokens}\r\n                  disabled={!selectedTokenIn || !selectedTokenOut}\r\n                >\r\n                  <ArrowDown className=\"h-4 w-4\" />\r\n                </Button>\r\n              </div>\r\n\r\n              {/* Token Output Field */}\r\n              <FormField\r\n                control={form.control}\r\n                name=\"tokenOut\"\r\n                render={({ field }) => (\r\n                  <FormItem className=\"bg-secondary/50 rounded-lg p-4\">\r\n                    <div className=\"flex justify-between items-center\">\r\n                      <FormLabel>You Receive</FormLabel>\r\n                      {selectedTokenOut && showTokenBalance && (\r\n                        <div className=\"text-xs text-muted-foreground\">\r\n                          Balance: {selectedTokenOut.balance.toLocaleString(undefined, {\r\n                            minimumFractionDigits: 0,\r\n                            maximumFractionDigits: selectedTokenOut.decimals > 6 ? 6 : selectedTokenOut.decimals,\r\n                          })}\r\n                        </div>\r\n                      )}\r\n                    </div>\r\n                    <div className=\"flex items-center space-x-2 mt-2\">\r\n                      <FormControl>\r\n                        <Input\r\n                          type=\"text\"\r\n                          placeholder=\"0.0\"\r\n                          value={amountOutValue}\r\n                          disabled={true} // Always disabled - calculated from input\r\n                          className=\"bg-transparent border-none text-xl font-medium placeholder:text-muted-foreground focus-visible:ring-0 focus-visible:ring-offset-0\"\r\n                        />\r\n                      </FormControl>\r\n                      <Select\r\n                        onValueChange={(value) => handleTokenChange(false, value)}\r\n                        value={field.value}\r\n                        disabled={!connected}\r\n                      >\r\n                        <FormControl>\r\n                          <SelectTrigger className=\"min-w-[140px] h-auto bg-background\">\r\n                            <SelectValue\r\n                              placeholder={\r\n                                isLoadingTokens || isUpdatingBalance\r\n                                  ? \"Loading...\"\r\n                                  : \"Select\"\r\n                              }\r\n                            >\r\n                              {selectedTokenOut && (\r\n                                <div className=\"flex items-center\">\r\n                                  {selectedTokenOut.icon && (\r\n                                    <img\r\n                                      src={selectedTokenOut.icon}\r\n                                      alt={selectedTokenOut.symbol}\r\n                                      className=\"w-5 h-5 mr-2 rounded-full\"\r\n                                    />\r\n                                  )}\r\n                                  {selectedTokenOut.symbol}\r\n                                </div>\r\n                              )}\r\n                            </SelectValue>\r\n                          </SelectTrigger>\r\n                        </FormControl>\r\n                        <SelectContent>\r\n                          {isLoadingTokens || isUpdatingBalance ? (\r\n                            <div className=\"flex items-center justify-center p-2\">\r\n                              <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\r\n                              <span>\r\n                                {isUpdatingBalance\r\n                                  ? \"Updating balances...\"\r\n                                  : \"Loading tokens...\"}\r\n                              </span>\r\n                            </div>\r\n                          ) : availableTokens.length > 0 ? (\r\n                            <SelectGroup>\r\n                              {availableTokens.map(renderTokenItem)}\r\n                            </SelectGroup>\r\n                          ) : (\r\n                            <div className=\"p-2 text-muted-foreground text-center\">\r\n                              No tokens found\r\n                            </div>\r\n                          )}\r\n                        </SelectContent>\r\n                      </Select>\r\n                    </div>\r\n                    <FormMessage />\r\n                  </FormItem>\r\n                )}\r\n              />\r\n            </div>\r\n            {/* Add swap button section */}\r\n            <div className=\"pt-2\">\r\n              {!connected ? (\r\n                <ConnectWalletButton className=\"w-full\" />\r\n              ) : (\r\n                <Button\r\n                  type=\"submit\"\r\n                  className=\"w-full\"\r\n                  disabled={\r\n                    isSubmitting ||\r\n                    isLoading ||\r\n                    !selectedTokenIn ||\r\n                    !selectedTokenOut ||\r\n                    !amountInValue ||\r\n                    parseFloat\r\n                    (amountInValue) <= 0 || \r\n                    isLoadingQuote\r\n                  }\r\n                  >\r\n                  {isSubmitting || isLoading? (\r\n                    <>\r\n                    <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\r\n                    Swapping...\r\n                    </>\r\n                  ) : (\r\n                    \"Swap\"\r\n                  )}\r\n                  </Button>\r\n                )}\r\n            </div>\r\n\r\n\r\n            {/*/ Add exchange rate info if quote exists */}\r\n            {quoteResult && (\r\n              <div className=\"space-y-1\">\r\n                <div className=\"text-sm text-muted-foreground text-center\">\r\n                  1 {selectedTokenIn?.symbol} ≈ {quoteResult.exchangeRate.toLocaleString(undefined, {\r\n                    minimumFractionDigits: 2,\r\n                    maximumFractionDigits: 6\r\n                  })} {selectedTokenOut?.symbol}\r\n                </div>\r\n                <div className=\"text-xs text-center flex justify-center gap-2\">\r\n                  <span className=\"text-muted-foreground\">\r\n                    Slippage: {slippageValue.toFixed(1)}%\r\n                  </span>\r\n                  {quoteResult.priceImpactPct > 1 && (\r\n                    <span className={`${quoteResult.priceImpactPct > 3 ? 'text-red-500' : 'text-yellow-500'}`}>\r\n                      Price impact: {quoteResult.priceImpactPct.toFixed(2)}%\r\n                    </span>\r\n                  )}\r\n                </div>\r\n              </div>\r\n            )}\r\n          </form>\r\n        </Form>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "components/ui/murphy/swap-token-form.tsx"
    },
    {
      "path": "hook/murphy/use-JupiterTrade.ts",
      "content": "import { VersionedTransaction, PublicKey, Connection } from \"@solana/web3.js\";\r\nimport {\r\n  TOKENS,\r\n  DEFAULT_OPTIONS,\r\n  JUP_API,\r\n  JUP_REFERRAL_ADDRESS,\r\n} from \"../../constants/swap/jupiter-constants\";\r\nimport { getMint, getAccount, getAssociatedTokenAddress, TokenAccountNotFoundError, TokenInvalidAccountOwnerError } from \"@solana/spl-token\";\r\nimport { useWallet, WalletContextState } from \"@solana/wallet-adapter-react\";\r\nimport { config } from \"../../config/swap\";\r\nimport { useContext } from \"react\";\r\nimport { ModalContext } from \"@/components/providers/wallet-provider\";\r\n\r\n/**\r\n * Interface for quote result from Jupiter\r\n */\r\nexport interface QuoteResponse {\r\n  inputMint: string;\r\n  outputMint: string;\r\n  amount: string;\r\n  otherAmountThreshold: string;\r\n  swapMode: string;\r\n  slippageBps: number;\r\n  platformFee?: {\r\n    amount: string;\r\n    feeBps: number;\r\n  };\r\n  priceImpactPct: number;\r\n  routePlan: any[];\r\n  contextSlot: number;\r\n  timeTaken: number;\r\n  outAmount: string;\r\n  outAmountWithSlippage?: string;\r\n}\r\n\r\n/**\r\n * Get swap quote from Jupiter API\r\n * @param inputMint Mint address of input token\r\n * @param outputMint Mint address of output token\r\n * @param amount Amount of input token (scaled by decimals)\r\n * @param slippageBps Maximum slippage tolerance (basis points)\r\n * @returns Quote result\r\n */\r\nexport async function fetchQuote(\r\n  outputMint: PublicKey,\r\n  amount: number | string,\r\n  inputMint: PublicKey,\r\n  slippageBps: number = DEFAULT_OPTIONS.SLIPPAGE_BPS,\r\n  useDynamicSlippage: boolean = false\r\n): Promise<any> {\r\n  try {\r\n    // Convert amount to string to avoid issues with large numbers\r\n    const amountStr = amount.toString();\r\n    \r\n    console.log(`fetchQuote: inputMint=${inputMint.toString()}, outputMint=${outputMint.toString()}, amount=${amountStr}`);\r\n    \r\n    // Validate parameters\r\n    if (!inputMint || !outputMint || !amount || parseFloat(amountStr) <= 0) {\r\n      throw new Error(\"Invalid quote parameters\");\r\n    }\r\n    \r\n    // Check if input token is native SOL\r\n    const isNativeSol = inputMint.equals(TOKENS.SOL);\r\n    \r\n    const apiUrl = `${JUP_API}/quote?` +\r\n      `inputMint=${isNativeSol ? TOKENS.SOL.toString() : inputMint.toString()}` +\r\n      `&outputMint=${outputMint.toString()}` +\r\n      `&amount=${amountStr}` +\r\n      `&slippageBps=${slippageBps}` +\r\n      `&minimizeSlippage=false` +\r\n      `&onlyDirectRoutes=false` +\r\n      `&maxAccounts=64` +\r\n      `&swapMode=ExactIn`;\r\n    \r\n    console.log(`Sending API request: ${apiUrl}`);\r\n    \r\n    const response = await fetch(apiUrl, {\r\n      method: 'GET',\r\n      headers: {\r\n        'Accept': 'application/json',\r\n      },\r\n      mode: 'cors',\r\n    });\r\n    \r\n    // Check for HTTP errors\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      console.error(`Jupiter API error (${response.status}): ${errorText}`);\r\n      \r\n      if (response.status === 400) {\r\n        throw new Error(`Unable to get quote: Invalid token amount or insufficient liquidity (${response.status})`);\r\n      } else if (response.status === 429) {\r\n        throw new Error(\"Too many requests, please try again later\");\r\n      } else {\r\n        throw new Error(`API error: ${response.status} - ${errorText || 'No error information'}`);\r\n      }\r\n    }\r\n    \r\n    const quoteResponse = await response.json();\r\n    \r\n    // Check if data is valid\r\n    if (!quoteResponse) {\r\n      console.error(\"Invalid quote data:\", quoteResponse);\r\n      throw new Error(\"Invalid quote data\");\r\n    }\r\n    \r\n    console.log(\"Received quote:\", quoteResponse);\r\n    return quoteResponse;\r\n  } catch (error: any) {\r\n    console.error(\"Error fetching quote:\", error);\r\n    throw new Error(`Unable to fetch quote: ${error.message || 'Unknown error'}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Scale token amount by decimals\r\n * @param amount Token amount (user input)\r\n * @param decimals Token decimals\r\n */\r\nexport function scaleAmount(amount: number, decimals: number): number {\r\n  return amount * Math.pow(10, decimals);\r\n}\r\n\r\n/**\r\n * Format token amount from lamports to decimals\r\n * @param amount Token amount (in lamports)\r\n * @param decimals Token decimals\r\n */\r\nexport function formatAmount(amount: string | number, decimals: number): string {\r\n  try {\r\n    // Convert amount to string if it's a number\r\n    const amountStr = typeof amount === 'number' ? amount.toString() : amount;\r\n    \r\n    // Convert to BigInt for precise handling of large numbers\r\n    const amountBigInt = BigInt(amountStr);\r\n    \r\n    // Check if amount is zero\r\n    if (amountBigInt === BigInt(0)) {\r\n      return '0';\r\n    }\r\n    \r\n    const divisor = BigInt(10 ** decimals);\r\n    \r\n    // Calculate whole part\r\n    const wholePart = amountBigInt / divisor;\r\n    \r\n    // Calculate fractional part\r\n    const fractionalPart = amountBigInt % divisor;\r\n    \r\n    // Format fractional part\r\n    let fractionalStr = fractionalPart.toString().padStart(decimals, '0');\r\n    \r\n    // For SOL and very small amounts, ensure we show enough decimal places\r\n    if (decimals === 9 && wholePart === BigInt(0) && fractionalPart > BigInt(0)) {\r\n      // Format with fixed decimal places for visibility\r\n      const formattedNumber = Number(amountBigInt) / Number(divisor);\r\n      console.log(`Formatting small SOL amount: ${formattedNumber}`);\r\n      \r\n      // Ensure we display at least 4 significant digits\r\n      // For 0.006, this would show 0.006 (not rounded)\r\n      return formattedNumber.toFixed(Math.max(3, decimals.toString().length));\r\n    }\r\n    \r\n    // Normal formatting for larger amounts\r\n    // Remove trailing zeros but keep at least one decimal for small values\r\n    const trimmedFractional = fractionalStr.replace(/0+$/, '');\r\n    \r\n    // If whole part is 0 and fractional part exists but would be trimmed to empty,\r\n    // keep at least 4 decimal places to show small values\r\n    if (wholePart === BigInt(0) && fractionalPart > BigInt(0) && trimmedFractional === '') {\r\n      // Find first non-zero digit\r\n      let significantDigits = 0;\r\n      for (let i = 0; i < fractionalStr.length; i++) {\r\n        if (fractionalStr[i] !== '0') {\r\n          significantDigits = i;\r\n          break;\r\n        }\r\n      }\r\n      // Show at least the first non-zero digit and a few more\r\n      const digitsToShow = Math.min(significantDigits + 3, fractionalStr.length);\r\n      fractionalStr = fractionalStr.substring(0, digitsToShow);\r\n    } else {\r\n      fractionalStr = trimmedFractional;\r\n    }\r\n    \r\n    // If no fractional part, return only whole part\r\n    if (fractionalStr === '') {\r\n      return wholePart.toString();\r\n    }\r\n    \r\n    // Combine whole and fractional parts\r\n    return `${wholePart.toString()}.${fractionalStr}`;\r\n  } catch (error) {\r\n    console.error(\"Error formatting token amount:\", error);\r\n    return '0';\r\n  }\r\n}\r\n\r\n// Hardcoded decimals for common tokens to avoid errors when querying blockchain\r\nconst TOKEN_DECIMALS: { [key: string]: number } = {\r\n  // USDC\r\n  'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 6,\r\n  // USDT\r\n  'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': 6,\r\n  // SOL (wrapped)\r\n  'So11111111111111111111111111111111111111112': 9,\r\n  // BONK\r\n  'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': 5,\r\n  // jitoSOL\r\n  'J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn': 9,\r\n  // bSOL\r\n  'bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1': 9,\r\n  // mSOL\r\n  'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So': 9,\r\n  // USDS\r\n  'USDSwr9ApdHk5bvJKMjzff41FfuX8bSxdKcR81vTwcA': 6,\r\n};\r\n\r\n/**\r\n * Function to get the decimals of a token by mint address\r\n */\r\nconst getTokenDecimals = (mintAddress: string): number => {\r\n  // Use value from TOKEN_DECIMALS if available\r\n  if (TOKEN_DECIMALS[mintAddress]) {\r\n    return TOKEN_DECIMALS[mintAddress];\r\n  }\r\n  \r\n  // Default value if not found\r\n  console.warn(`Decimals for token ${mintAddress} not found, using default 6`);\r\n  return 6;\r\n};\r\n\r\n/**\r\n * Solana blockchain token swap function, using Jupiter API\r\n */\r\nconst trade = async (\r\n  outputMint: PublicKey,\r\n  inputAmount: number,\r\n  inputMint: PublicKey = TOKENS.USDC,\r\n  slippageBps: number = DEFAULT_OPTIONS.SLIPPAGE_BPS,\r\n  walletPublicKey: string, \r\n  wallet: any,\r\n  connectionEndpoint: string\r\n) => {\r\n  try {\r\n    // Check if all necessary parameters are provided\r\n    if (!connectionEndpoint) {\r\n      throw new Error(\"Connection endpoint is not defined\");\r\n    }\r\n    \r\n    if (!walletPublicKey) {\r\n      throw new Error(\"Wallet public key is not defined\");\r\n    }\r\n    \r\n    if (!wallet) {\r\n      throw new Error(\"Wallet is not defined\");\r\n    }\r\n    \r\n    // Check if wallet has signTransaction function\r\n    console.log(\"Checking wallet before trade:\", {\r\n      walletType: typeof wallet,\r\n      hasSignTransaction: typeof wallet.signTransaction === 'function'\r\n    });\r\n    \r\n    if (typeof wallet.signTransaction !== 'function') {\r\n      throw new Error(\"Wallet does not have signTransaction method\");\r\n    }\r\n    \r\n    // Create connection to Solana blockchain\r\n    const connection = new Connection(connectionEndpoint, {\r\n      commitment: 'confirmed',\r\n      confirmTransactionInitialTimeout: 60000\r\n    });\r\n\r\n    // Display transaction information\r\n    console.log(`Executing swap with slippage ${slippageBps / 100}%`);\r\n    console.log(\"Input token decimal:\", getTokenDecimals(inputMint.toString()));\r\n    console.log(\"Output token decimal:\", getTokenDecimals(outputMint.toString()));\r\n    \r\n    // Adjust calculation of scaledAmount to only take the integer part\r\n    const inputDecimals = getTokenDecimals(inputMint.toString());\r\n    const scaledAmount = Math.floor(inputAmount * Math.pow(10, inputDecimals));\r\n    console.log(\"Scaled amount:\", scaledAmount);\r\n\r\n    // Get quote from Jupiter API\r\n    const quoteResponse = await fetch(\r\n      `${JUP_API}/quote?inputMint=${inputMint.toString()}&outputMint=${outputMint.toString()}&amount=${scaledAmount}&slippageBps=${slippageBps}`,\r\n      {\r\n        method: \"GET\",\r\n      }\r\n    );\r\n\r\n    if (!quoteResponse.ok) {\r\n      const errorText = await quoteResponse.text();\r\n      console.error(`Jupiter API error (${quoteResponse.status}): ${errorText}`);\r\n      \r\n      if (quoteResponse.status === 400) {\r\n        throw new Error(`Unable to get quote: Invalid token amount or insufficient liquidity (${quoteResponse.status}) - ${errorText}`);\r\n      } else if (quoteResponse.status === 429) {\r\n        throw new Error(\"Too many requests, please try again later\");\r\n      } else {\r\n        throw new Error(`API error: ${quoteResponse.status} - ${errorText || 'No error information'}`);\r\n      }\r\n    }\r\n\r\n    const quote = await quoteResponse.json();\r\n    console.log(\"Quote response:\", quote);\r\n    \r\n    // Set up referral fee if available\r\n    const jupiterReferralAccount = process.env.NEXT_PUBLIC_JUPITER_REFERRAL_ACCOUNT;\r\n    const referralAccount = jupiterReferralAccount ? new PublicKey(jupiterReferralAccount) : undefined;\r\n\r\n    // Execute swap\r\n    const swapResponse = await fetch(`${JUP_API}/swap`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({\r\n        quoteResponse: quote,\r\n        userPublicKey: walletPublicKey,\r\n        feeAccount: referralAccount?.toString(),\r\n        wrapAndUnwrapSol: true,\r\n      }),\r\n    });\r\n\r\n    if (!swapResponse.ok) {\r\n      throw new Error(`Error executing swap: ${swapResponse.status} ${swapResponse.statusText}`);\r\n    }\r\n\r\n    const swapResult = await swapResponse.json();\r\n    console.log(\"Swap result:\", swapResult);\r\n\r\n    // Decode transaction\r\n    const swapTransaction = VersionedTransaction.deserialize(\r\n      Buffer.from(swapResult.swapTransaction, \"base64\")\r\n    );\r\n\r\n    // Sign and send transaction\r\n    try {\r\n      console.log(\"Signing transaction with wallet:\", typeof wallet.signTransaction);\r\n      const signedTransaction = await wallet.signTransaction(swapTransaction);\r\n      console.log(\"Transaction successfully signed\");\r\n      \r\n      const txid = await connection.sendRawTransaction(\r\n        signedTransaction.serialize()\r\n      );\r\n      console.log(\"Transaction sent. Txid:\", txid);\r\n      \r\n      console.log(\"Waiting for transaction confirmation...\");\r\n      const confirmation = await connection.confirmTransaction(txid, \"confirmed\");\r\n      console.log(\"Transaction confirmed:\", confirmation);\r\n      \r\n      return { success: true, txid };\r\n    } catch (error: any) {\r\n      console.error(\"Error signing or sending transaction:\", error);\r\n      throw new Error(`Error signing or sending transaction: ${error.message}`);\r\n    }\r\n  } catch (error: any) {\r\n    console.error(\"Error during trade execution:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get token balance for a wallet address\r\n * @param walletAddress Wallet address to check balance for\r\n * @param tokenMint Token mint address to check\r\n * @param connection Solana connection\r\n * @returns Balance as a string with proper decimal formatting\r\n */\r\nexport async function getTokenBalance(\r\n  walletAddress: PublicKey,\r\n  tokenMint: PublicKey,\r\n  connection: Connection\r\n): Promise<string> {\r\n  try {\r\n    console.log(`Fetching balance for token: ${tokenMint.toString()} for wallet: ${walletAddress.toString()}`);\r\n    \r\n    // Check if token is SOL (native)\r\n    if (tokenMint.equals(TOKENS.SOL)) {\r\n      console.log(\"Getting native SOL balance\");\r\n      // For native SOL, get the account info directly\r\n      const balance = await connection.getBalance(walletAddress);\r\n      console.log(`Raw SOL balance: ${balance}`);\r\n      const formattedBalance = formatAmount(balance.toString(), 9); // SOL has 9 decimals\r\n      console.log(`Formatted SOL balance: ${formattedBalance}`);\r\n      return formattedBalance;\r\n    }\r\n\r\n    // For SPL tokens, get the associated token account\r\n    const tokenAccount = await getAssociatedTokenAddress(\r\n      tokenMint,\r\n      walletAddress\r\n    );\r\n    console.log(`Token account address: ${tokenAccount.toString()}`);\r\n\r\n    try {\r\n      // Get token decimals first\r\n      let decimals = 9; // Default\r\n      \r\n      // Use hardcoded decimals if available\r\n      const mintString = tokenMint.toString();\r\n      console.log(`Checking decimals for token: ${mintString}`);\r\n      \r\n      if (TOKEN_DECIMALS[mintString]) {\r\n        decimals = TOKEN_DECIMALS[mintString];\r\n        console.log(`Using hardcoded decimals: ${decimals}`);\r\n      } else {\r\n        // Otherwise query the mint\r\n        try {\r\n          console.log(\"Querying mint info for decimals\");\r\n          const mintInfo = await getMint(connection, tokenMint);\r\n          decimals = mintInfo.decimals;\r\n          console.log(`Got decimals from mint: ${decimals}`);\r\n        } catch (e) {\r\n          console.error(\"Error getting mint info:\", e);\r\n          console.log(\"Using default decimals (9)\");\r\n          // Keep default decimals\r\n        }\r\n      }\r\n      \r\n      // Now get account info for the token account\r\n      console.log(\"Fetching token account info\");\r\n      const account = await getAccount(connection, tokenAccount);\r\n      console.log(`Raw token amount: ${account.amount.toString()}`);\r\n      \r\n      // Format the balance with proper decimals\r\n      const formattedBalance = formatAmount(account.amount.toString(), decimals);\r\n      console.log(`Formatted token balance: ${formattedBalance} (using ${decimals} decimals)`);\r\n      return formattedBalance;\r\n    } catch (error) {\r\n      // Check if error is due to account not found\r\n      if (\r\n        error instanceof TokenAccountNotFoundError ||\r\n        error instanceof TokenInvalidAccountOwnerError\r\n      ) {\r\n        console.log(\"Token account not found or invalid owner, balance is 0\");\r\n        // If account doesn't exist, balance is 0\r\n        return \"0\";\r\n      }\r\n      console.error(\"Error getting token account:\", error);\r\n      throw error;\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching token balance:\", error);\r\n    return \"0\";\r\n  }\r\n}\r\n\r\n// Hook to use in React components\r\nexport function useJupiterTrade() {\r\n  const { endpoint } = useContext(ModalContext);\r\n  const wallet = useWallet();\r\n  const { publicKey } = wallet;\r\n\r\n  /**\r\n   * Get swap token quote\r\n   */\r\n  const getQuote = async (\r\n    outputMint: PublicKey,\r\n    inputAmount: number, // decimal number\r\n    inputMint: PublicKey = TOKENS.USDC,\r\n    slippageBps: number = DEFAULT_OPTIONS.SLIPPAGE_BPS\r\n  ) => {\r\n    try {\r\n      if (!inputAmount || inputAmount <= 0) throw new Error(\"Invalid token amount\");\r\n      if (inputMint.equals(outputMint)) throw new Error(\"Input and output tokens must be different\");\r\n  \r\n      // Get decimals for input\r\n      let inputDecimals = TOKEN_DECIMALS[inputMint.toString()] ?? 9;\r\n      // Scale inputAmount to smallest unit and round down to avoid decimals\r\n      const scaledAmount = Math.floor(inputAmount * Math.pow(10, inputDecimals));\r\n      if (scaledAmount <= 0) throw new Error(\"Invalid token amount after conversion\");\r\n  \r\n      // Call Jupiter API\r\n      const quote = await fetchQuote(outputMint, scaledAmount, inputMint, slippageBps, false);\r\n      if (!quote) throw new Error(\"Unable to get quote\");\r\n  \r\n      // Get decimals for output\r\n      let outputDecimals = TOKEN_DECIMALS[outputMint.toString()] ?? 9;\r\n      // Format output (decimal number)\r\n      const outAmount = quote.outAmount ? quote.outAmount : 0;\r\n      const formattedOutAmount = formatAmount(outAmount, outputDecimals);\r\n  \r\n      // Calculate exchange rate\r\n      const exchangeRate = inputAmount > 0 ? parseFloat(formattedOutAmount) / inputAmount : 0;\r\n      const priceImpactPct = quote.priceImpactPct ? parseFloat(quote.priceImpactPct) : 0;\r\n  \r\n      return {\r\n        outputAmount: formattedOutAmount,\r\n        exchangeRate,\r\n        priceImpactPct,\r\n        routeInfo: quote.routePlan || null\r\n      };\r\n    } catch (error: any) {\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Execute token swap transaction\r\n   */\r\n  const executeTrade = async (\r\n    outputMint: PublicKey,\r\n    inputAmount: number,\r\n    inputMint: PublicKey = TOKENS.USDC,\r\n    slippageBps: number = DEFAULT_OPTIONS.SLIPPAGE_BPS\r\n  ) => {\r\n    try {\r\n      // Check if wallet is connected and has endpoint\r\n      if (!publicKey || !endpoint) {\r\n        console.error(\"publicKey or endpoint does not exist:\", { publicKey, endpoint });\r\n        throw new Error(\"Wallet not connected or endpoint not defined\");\r\n      }\r\n\r\n      // Check input parameters\r\n      console.log(\"Checking input parameters for trade:\", {\r\n        inputAmount,\r\n        inputMintStr: inputMint.toString(),\r\n        outputMintStr: outputMint.toString(),\r\n        slippageBps,\r\n        inputAmountType: typeof inputAmount\r\n      });\r\n\r\n      // Check if inputAmount is a positive number\r\n      if (typeof inputAmount !== 'number' || isNaN(inputAmount) || inputAmount <= 0) {\r\n        throw new Error(`Invalid token amount: ${inputAmount}`);\r\n      }\r\n\r\n      // Use wallet directly from useWallet hook\r\n      console.log(\"Checking wallet details:\", {\r\n        connected: wallet?.connected,\r\n        publicKey: publicKey?.toString(),\r\n        hasSignTransaction: !!wallet?.signTransaction,\r\n        signTransactionType: typeof wallet?.signTransaction\r\n      });\r\n\r\n      // Check if wallet supports signTransaction method\r\n      if (!wallet || typeof wallet.signTransaction !== 'function') {\r\n        throw new Error(\"Wallet does not support signTransaction method\");\r\n      }\r\n\r\n      // Call trade function with full parameters\r\n      console.log(\"Calling trade function with parameters:\", {\r\n        outputMint: outputMint.toString(),\r\n        inputAmount,\r\n        inputMint: inputMint.toString(),\r\n        slippageBps,\r\n        publicKey: publicKey.toString()\r\n      });\r\n\r\n      return await trade(\r\n        outputMint,\r\n        inputAmount,\r\n        inputMint,\r\n        slippageBps,\r\n        publicKey.toString(),\r\n        wallet,\r\n        endpoint\r\n      );\r\n    } catch (error: any) {\r\n      console.error(\"Error in executeTrade:\", error);\r\n      throw new Error(`Unable to execute trade: ${error.message}`);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get balance for a token\r\n   */\r\n  const getBalance = async (\r\n    tokenMint: PublicKey\r\n  ): Promise<string> => {\r\n    if (!publicKey || !endpoint) {\r\n      console.log(\"getBalance: Wallet not connected or endpoint not defined\");\r\n      return \"0\";\r\n    }\r\n    \r\n    console.log(`getBalance: Checking balance for token ${tokenMint.toString()}`);\r\n    console.log(`getBalance: Using endpoint ${endpoint}`);\r\n    console.log(`getBalance: Wallet address ${publicKey.toString()}`);\r\n    \r\n    // Create a promise with timeout to avoid hanging\r\n    const timeoutPromise = new Promise<string>((_, reject) => {\r\n      setTimeout(() => {\r\n        reject(new Error(\"getBalance: Connection timeout after 10 seconds\"));\r\n      }, 10000); // 10 seconds timeout\r\n    });\r\n    \r\n    try {\r\n      // Race between API call and timeout\r\n      return await Promise.race([\r\n        (async () => {\r\n          // Try using direct connection to Solana RPC\r\n          try {\r\n            console.log(\"getBalance: Creating direct connection to Solana RPC\");\r\n            \r\n            // Create connection with optimized options\r\n            const connection = new Connection(endpoint, {\r\n              commitment: 'confirmed',\r\n              confirmTransactionInitialTimeout: 10000,\r\n              disableRetryOnRateLimit: false,\r\n            });\r\n            \r\n            console.log(\"getBalance: Created connection object\");\r\n            \r\n            // Skip connection check to avoid 403 error\r\n            // Go straight to getting SOL balance\r\n            \r\n            // Special handling for SOL\r\n            if (tokenMint.equals(TOKENS.SOL)) {\r\n              console.log(\"getBalance: Getting SOL balance (special handling)\");\r\n              try {\r\n                console.log(`getBalance: Getting SOL balance for wallet ${publicKey.toString()}`);\r\n                \r\n                // Use try-catch for each API call\r\n                const rawBalance = await connection.getBalance(publicKey);\r\n                console.log(`getBalance: Raw SOL balance in lamports: ${rawBalance}`);\r\n                \r\n                // Convert lamports to SOL directly\r\n                const solBalance = rawBalance / 1000000000;\r\n                console.log(`getBalance: SOL balance in SOL units: ${solBalance}`);\r\n                \r\n                // SPECIAL: Display small SOL with enough decimal places\r\n                if (solBalance > 0) {\r\n                  // Always display small SOL balance with fixed format, regardless of size\r\n                  const formatted = solBalance.toFixed(6);\r\n                  console.log(`getBalance: Formatted SOL balance for small amount: ${formatted}`);\r\n                  return formatted;\r\n                }\r\n                \r\n                if (solBalance === 0) {\r\n                  return \"0\";\r\n                }\r\n                \r\n                // Fallback: Use standard formatter\r\n                const formattedBalance = formatAmount(rawBalance.toString(), 9);\r\n                console.log(`getBalance: Formatted SOL balance: ${formattedBalance}`);\r\n                return formattedBalance;\r\n              } catch (error) {\r\n                console.error(\"getBalance: Error getting SOL balance:\", error);\r\n                return \"0\";\r\n              }\r\n            }\r\n            \r\n            // For SPL tokens, try getting token account\r\n            try {\r\n              // Try simpler method for SPL token instead of using getTokenBalance\r\n              const tokenAccount = await getAssociatedTokenAddress(\r\n                tokenMint,\r\n                publicKey\r\n              );\r\n              console.log(`Token account address: ${tokenAccount.toString()}`);\r\n              \r\n              try {\r\n                // Get decimals from hardcoded values instead of querying blockchain\r\n                const mintString = tokenMint.toString();\r\n                let decimals = 9; // Default\r\n                \r\n                if (TOKEN_DECIMALS[mintString]) {\r\n                  decimals = TOKEN_DECIMALS[mintString];\r\n                  console.log(`Using hardcoded decimals: ${decimals}`);\r\n                }\r\n                \r\n                // Get token account info\r\n                const account = await getAccount(connection, tokenAccount);\r\n                console.log(`Raw token amount: ${account.amount.toString()}`);\r\n                \r\n                // Format balance with correct decimals\r\n                return formatAmount(account.amount.toString(), decimals);\r\n              } catch (error) {\r\n                // Handle case where token account does not exist\r\n                if (error instanceof TokenAccountNotFoundError) {\r\n                  console.log(\"Token account not found, balance is 0\");\r\n                  return \"0\";\r\n                }\r\n                console.error(\"Error getting token account:\", error);\r\n                return \"0\";\r\n              }\r\n            } catch (tokenError) {\r\n              console.error(\"getBalance: Error setting up token account check:\", tokenError);\r\n              return \"0\";\r\n            }\r\n          } catch (connectionError) {\r\n            console.error(\"getBalance: Could not establish connection:\", connectionError);\r\n            return \"0\";\r\n          }\r\n        })(),\r\n        timeoutPromise\r\n      ]);\r\n    } catch (error) {\r\n      console.error(\"getBalance: Error getting balance:\", error);\r\n      return \"0\";\r\n    }\r\n  };\r\n\r\n  return { executeTrade, getQuote, getBalance };\r\n}",
      "type": "registry:hook",
      "target": "hook/murphy/use-JupiterTrade.ts"
    },
    {
      "path": "config/swap/index.ts",
      "content": "import { Config } from \"../../types/swap\";\r\n\r\nexport const config: Config = {\r\n  JUPITER_REFERRAL_ACCOUNT: undefined,\r\n  JUPITER_FEE_BPS: 0,\r\n};\r\n",
      "type": "registry:file",
      "target": "config/swap/index.ts"
    },
    {
      "path": "constants/swap/jupiter-constants.ts",
      "content": "import { PublicKey } from \"@solana/web3.js\";\r\n\r\nexport const JUP_API = \"https://quote-api.jup.ag/v6\";\r\nexport const JUP_REFERRAL_ADDRESS = \"JUPTRFXx5qe2wMFBtC7c7s6DvS3weDgAZu7Lr4ZKtoQ\";\r\n\r\nexport const DEFAULT_OPTIONS = {\r\n  SLIPPAGE_BPS: 50, // 0.5%\r\n};\r\n\r\nexport const TOKENS = {\r\n  SOL: new PublicKey(\"So11111111111111111111111111111111111111112\"),\r\n  USDC: new PublicKey(\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"),\r\n  USDT: new PublicKey(\"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB\")\r\n};",
      "type": "registry:file",
      "target": "constants/swap/jupiter-constants.ts"
    },
    {
      "path": "types/swap/index.ts",
      "content": "import { PublicKey, Connection } from \"@solana/web3.js\";\r\n\r\nexport interface Config {\r\n    JUPITER_REFERRAL_ACCOUNT?: string;\r\n    JUPITER_FEE_BPS?: number;\r\n}\r\n  \r\ndeclare const _default: {\r\n    Config: Config;\r\n};\r\n\r\n\r\nexport default _default; ",
      "type": "registry:file",
      "target": "types/swap/index.ts"
    },
    {
      "path": "public/crypto-logos/solana-logo.svg",
      "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 24.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\r\n<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\r\n\t viewBox=\"0 0 397.7 311.7\" style=\"enable-background:new 0 0 397.7 311.7;\" xml:space=\"preserve\">\r\n<style type=\"text/css\">\r\n\t.st0{fill:url(#SVGID_1_);}\r\n\t.st1{fill:url(#SVGID_2_);}\r\n\t.st2{fill:url(#SVGID_3_);}\r\n</style>\r\n<linearGradient id=\"SVGID_1_\" gradientUnits=\"userSpaceOnUse\" x1=\"360.8791\" y1=\"351.4553\" x2=\"141.213\" y2=\"-69.2936\" gradientTransform=\"matrix(1 0 0 -1 0 314)\">\r\n\t<stop  offset=\"0\" style=\"stop-color:#00FFA3\"/>\r\n\t<stop  offset=\"1\" style=\"stop-color:#DC1FFF\"/>\r\n</linearGradient>\r\n<path class=\"st0\" d=\"M64.6,237.9c2.4-2.4,5.7-3.8,9.2-3.8h317.4c5.8,0,8.7,7,4.6,11.1l-62.7,62.7c-2.4,2.4-5.7,3.8-9.2,3.8H6.5\r\n\tc-5.8,0-8.7-7-4.6-11.1L64.6,237.9z\"/>\r\n<linearGradient id=\"SVGID_2_\" gradientUnits=\"userSpaceOnUse\" x1=\"264.8291\" y1=\"401.6014\" x2=\"45.163\" y2=\"-19.1475\" gradientTransform=\"matrix(1 0 0 -1 0 314)\">\r\n\t<stop  offset=\"0\" style=\"stop-color:#00FFA3\"/>\r\n\t<stop  offset=\"1\" style=\"stop-color:#DC1FFF\"/>\r\n</linearGradient>\r\n<path class=\"st1\" d=\"M64.6,3.8C67.1,1.4,70.4,0,73.8,0h317.4c5.8,0,8.7,7,4.6,11.1l-62.7,62.7c-2.4,2.4-5.7,3.8-9.2,3.8H6.5\r\n\tc-5.8,0-8.7-7-4.6-11.1L64.6,3.8z\"/>\r\n<linearGradient id=\"SVGID_3_\" gradientUnits=\"userSpaceOnUse\" x1=\"312.5484\" y1=\"376.688\" x2=\"92.8822\" y2=\"-44.061\" gradientTransform=\"matrix(1 0 0 -1 0 314)\">\r\n\t<stop  offset=\"0\" style=\"stop-color:#00FFA3\"/>\r\n\t<stop  offset=\"1\" style=\"stop-color:#DC1FFF\"/>\r\n</linearGradient>\r\n<path class=\"st2\" d=\"M333.1,120.1c-2.4-2.4-5.7-3.8-9.2-3.8H6.5c-5.8,0-8.7,7-4.6,11.1l62.7,62.7c2.4,2.4,5.7,3.8,9.2,3.8h317.4\r\n\tc5.8,0,8.7-7,4.6-11.1L333.1,120.1z\"/>\r\n</svg>\r\n",
      "type": "registry:file",
      "target": "public/crypto-logos/solana-logo.svg"
    },
    {
      "path": "public/crypto-logos/usd-coin-usdc-logo.svg",
      "content": "<svg data-name=\"86977684-12db-4850-8f30-233a7c267d11\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 2000 2000\">\r\n  <path d=\"M1000 2000c554.17 0 1000-445.83 1000-1000S1554.17 0 1000 0 0 445.83 0 1000s445.83 1000 1000 1000z\" fill=\"#2775ca\"/>\r\n  <path d=\"M1275 1158.33c0-145.83-87.5-195.83-262.5-216.66-125-16.67-150-50-150-108.34s41.67-95.83 125-95.83c75 0 116.67 25 137.5 87.5 4.17 12.5 16.67 20.83 29.17 20.83h66.66c16.67 0 29.17-12.5 29.17-29.16v-4.17c-16.67-91.67-91.67-162.5-187.5-170.83v-100c0-16.67-12.5-29.17-33.33-33.34h-62.5c-16.67 0-29.17 12.5-33.34 33.34v95.83c-125 16.67-204.16 100-204.16 204.17 0 137.5 83.33 191.66 258.33 212.5 116.67 20.83 154.17 45.83 154.17 112.5s-58.34 112.5-137.5 112.5c-108.34 0-145.84-45.84-158.34-108.34-4.16-16.66-16.66-25-29.16-25h-70.84c-16.66 0-29.16 12.5-29.16 29.17v4.17c16.66 104.16 83.33 179.16 220.83 200v100c0 16.66 12.5 29.16 33.33 33.33h62.5c16.67 0 29.17-12.5 33.34-33.33v-100c125-20.84 208.33-108.34 208.33-220.84z\" fill=\"#fff\"/>\r\n  <path d=\"M787.5 1595.83c-325-116.66-491.67-479.16-370.83-800 62.5-175 200-308.33 370.83-370.83 16.67-8.33 25-20.83 25-41.67V325c0-16.67-8.33-29.17-25-33.33-4.17 0-12.5 0-16.67 4.16-395.83 125-612.5 545.84-487.5 941.67 75 233.33 254.17 412.5 487.5 487.5 16.67 8.33 33.34 0 37.5-16.67 4.17-4.16 4.17-8.33 4.17-16.66v-58.34c0-12.5-12.5-29.16-25-37.5zM1229.17 295.83c-16.67-8.33-33.34 0-37.5 16.67-4.17 4.17-4.17 8.33-4.17 16.67v58.33c0 16.67 12.5 33.33 25 41.67 325 116.66 491.67 479.16 370.83 800-62.5 175-200 308.33-370.83 370.83-16.67 8.33-25 20.83-25 41.67V1700c0 16.67 8.33 29.17 25 33.33 4.17 0 12.5 0 16.67-4.16 395.83-125 612.5-545.84 487.5-941.67-75-237.5-258.34-416.67-487.5-491.67z\" fill=\"#fff\"/>\r\n</svg>\r\n",
      "type": "registry:file",
      "target": "public/crypto-logos/usd-coin-usdc-logo.svg"
    },
    {
      "path": "public/crypto-logos/tether-usdt-logo.svg",
      "content": "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 339.43 295.27\"><title>tether-usdt-logo</title><path d=\"M62.15,1.45l-61.89,130a2.52,2.52,0,0,0,.54,2.94L167.95,294.56a2.55,2.55,0,0,0,3.53,0L338.63,134.4a2.52,2.52,0,0,0,.54-2.94l-61.89-130A2.5,2.5,0,0,0,275,0H64.45a2.5,2.5,0,0,0-2.3,1.45h0Z\" style=\"fill:#50af95;fill-rule:evenodd\"/><path d=\"M191.19,144.8v0c-1.2.09-7.4,0.46-21.23,0.46-11,0-18.81-.33-21.55-0.46v0c-42.51-1.87-74.24-9.27-74.24-18.13s31.73-16.25,74.24-18.15v28.91c2.78,0.2,10.74.67,21.74,0.67,13.2,0,19.81-.55,21-0.66v-28.9c42.42,1.89,74.08,9.29,74.08,18.13s-31.65,16.24-74.08,18.12h0Zm0-39.25V79.68h59.2V40.23H89.21V79.68H148.4v25.86c-48.11,2.21-84.29,11.74-84.29,23.16s36.18,20.94,84.29,23.16v82.9h42.78V151.83c48-2.21,84.12-11.73,84.12-23.14s-36.09-20.93-84.12-23.15h0Zm0,0h0Z\" style=\"fill:#fff;fill-rule:evenodd\"/></svg>",
      "type": "registry:file",
      "target": "public/crypto-logos/tether-usdt-logo.svg"
    }
  ]
}