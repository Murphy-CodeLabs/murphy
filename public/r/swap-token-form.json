{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "swap-token-form",
  "type": "registry:block",
  "title": "Swap Token Form",
  "description": "A simple swap token form component.",
  "dependencies": [
    "@solana/web3.js",
    "@solana/spl-token",
    "@solana/wallet-adapter-react",
    "@coral-xyz/anchor"
  ],
  "registryDependencies": [
    "input",
    "button",
    "form",
    "card",
    "sonner",
    "select",
    "dialog",
    "dropdown-menu"
  ],
  "files": [
    {
      "path": "components/ui/murphis/swap-token-form.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect, useMemo, useContext } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { toast } from \"sonner\";\nimport { ArrowDown, Loader2, RefreshCw, Settings } from \"lucide-react\";\nimport {\n  PublicKey,\n  Transaction,\n  LAMPORTS_PER_SOL,\n} from \"@solana/web3.js\";\nimport { useWallet, useConnection } from \"@solana/wallet-adapter-react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n  SelectGroup,\n} from \"@/components/ui/select\";\nimport { ConnectWalletButton } from \"./connect-wallet-button\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { Slider } from \"@/components/ui/slider\";\nimport { useJupiterTrade } from \"@/hook/murphis/use-JupiterTrade\";\nimport { ModalContext } from \"@/components/providers/wallet-provider\";\n\ndeclare global {\n  interface Window {\n    quoteTimeout: NodeJS.Timeout | null;\n  }\n}\n\n// Token info type\nexport type TokenInfo = {\n  id: string;\n  symbol: string;\n  name: string;\n  balance: number;\n  decimals: number;\n  mintAddress?: string;\n  icon?: string;\n};\n\n// Quote result interface - must match the result from Jupiter API\ninterface QuoteResult {\n  outputAmount: string;    // Amount of tokens received\n  exchangeRate: number;    // Exchange rate\n  priceImpactPct: number;  // Price impact (%)\n  routeInfo: any;          // Route information\n}\n\n// Type for swap form values\ntype SwapFormValues = {\n  tokenIn: string;\n  tokenOut: string;\n  amountIn: number | undefined;\n  amountOut: number | undefined;\n  slippage: number;\n};\n\n// Create custom resolver for form\nconst customResolver = (data: any) => {\n  const errors: any = {};\n\n  // Validate token input\n  if (!data.tokenIn) {\n    errors.tokenIn = {\n      type: \"required\",\n      message: \"Please select an input token\",\n    };\n  }\n\n  // Validate token output\n  if (!data.tokenOut) {\n    errors.tokenOut = {\n      type: \"required\",\n      message: \"Please select an output token\",\n    };\n  }\n\n  // Validate amount\n  if (data.amountIn === undefined || data.amountIn === null || data.amountIn === \"\") {\n    errors.amountIn = {\n      type: \"required\",\n      message: \"Amount is required\",\n    };\n  } else if (Number(data.amountIn) <= 0) {\n    errors.amountIn = {\n      type: \"min\",\n      message: \"Amount must be greater than 0\",\n    };\n  }\n\n  return {\n    values: Object.keys(errors).length === 0 ? data : {},\n    errors,\n  };\n};\n\n// Props interface\nexport interface SwapFormProps {\n  onSwap?: (values: SwapFormValues) => Promise<void>;\n  tokens?: TokenInfo[];\n  isLoading?: boolean;\n  showTokenBalance?: boolean;\n  className?: string;\n}\n\nexport function SwapForm({\n  onSwap,\n  tokens,\n  isLoading = false,\n  showTokenBalance = true,\n  className,\n}: SwapFormProps) {\n  // State variables\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [selectedTokenIn, setSelectedTokenIn] = useState<TokenInfo | null>(null);\n  const [selectedTokenOut, setSelectedTokenOut] = useState<TokenInfo | null>(null);\n  const [isLoadingTokens, setIsLoadingTokens] = useState(false);\n  const [isUpdatingBalance, setIsUpdatingBalance] = useState(false);\n  const [isLoadingQuote, setIsLoadingQuote] = useState(false);\n  const [quoteResult, setQuoteResult] = useState<QuoteResult | null>(null);\n  const [amountInValue, setAmountInValue] = useState<string>(\"\");\n  const [amountOutValue, setAmountOutValue] = useState<string>(\"\");\n  const [slippageValue, setSlippageValue] = useState<number>(0.5); // 0.5% default\n  const [slippageSettingsOpen, setSlippageSettingsOpen] = useState(false);\n  \n  const { publicKey, connected, sendTransaction, wallet } = useWallet();\n  const { connection } = useConnection();\n  const { executeTrade, getQuote } = useJupiterTrade();\n  const { endpoint } = useContext(ModalContext);\n\n  // Form setup with react-hook-form\n  const form = useForm<SwapFormValues>({\n    defaultValues: {\n      tokenIn: \"\",\n      tokenOut: \"\",\n      amountIn: undefined,\n      amountOut: undefined,\n      slippage: 0.5,\n    },\n    mode: \"onSubmit\",  // Only validate on submit\n    resolver: customResolver,  // Use our custom resolver\n  });\n\n  // Available tokens state\n  const [availableTokens, setAvailableTokens] = useState<TokenInfo[]>([]);\n\n  // Add state to store timeout\n  const [inputTimeout, setInputTimeout] = useState<NodeJS.Timeout | null>(null);\n\n  // Clear timeout when component unmounts\n  useEffect(() => {\n    return () => {\n      if (inputTimeout) {\n        clearTimeout(inputTimeout);\n      }\n    };\n  }, [inputTimeout]);\n\n  // Determine network from connection endpoint\n  const networkName = useMemo(() => {\n    if (!connection) return \"Unknown\";\n\n    const endpoint = connection.rpcEndpoint;\n\n    if (endpoint.includes(\"devnet\")) return \"Devnet\";\n    if (endpoint.includes(\"testnet\")) return \"Testnet\";\n    if (endpoint.includes(\"mainnet\")) return \"Mainnet\";\n    if (endpoint.includes(\"localhost\") || endpoint.includes(\"127.0.0.1\"))\n      return \"Localnet\";\n\n    // Custom endpoint - show partial URL\n    const url = new URL(endpoint);\n    return url.hostname;\n  }, [connection]);\n\n  // Fetch token accounts from wallet\n  const fetchTokenAccounts = async (ownerPublicKey: PublicKey) => {\n    try {\n      setIsLoadingTokens(true);\n\n      // Get SOL balance\n      let solBalance = 0;\n      try {\n        if(!connection){\n          throw new Error(\"No connection available\");\n        }\n        solBalance = (await connection.getBalance(ownerPublicKey)) / LAMPORTS_PER_SOL;\n\n        let retryCount = 0;\n        const maxRetries = 3;\n\n        while (retryCount < maxRetries) {\n          try {\n            solBalance = (await\n              connection.getBalance(ownerPublicKey)) / LAMPORTS_PER_SOL;\n              break;\n            } catch (error: any) {\n              retryCount++;\n              if (retryCount === maxRetries) {\n                throw error;\n              }\n\n              await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for 1 second before retrying\n            }\n          }\n      } catch (error: any) {\n        console.error(\"Error fetching SOL balance:\", error);\n        toast.error(\"Failed to fetch SOL balance\", {\n          description: error?.message || \"Please check your wallet connection\",\n        })\n      }\n\n      // Extended default tokens list\n      const defaultTokens: TokenInfo[] = [\n        {\n          id: \"sol\",\n          symbol: \"SOL\",\n          name: \"Solana\",\n          balance: solBalance,\n          decimals: 9,\n          mintAddress: \"So11111111111111111111111111111111111111112\",\n          icon: \"/crypto-logos/solana-logo.svg\",\n        },\n        {\n          id: \"usdc\",\n          symbol: \"USDC\",\n          name: \"USD Coin\",\n          balance: 0,\n          decimals: 6,\n          mintAddress: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n          icon: \"/crypto-logos/usd-coin-usdc-logo.svg\",\n        },\n        {\n          id: \"usdt\",\n          symbol: \"USDT\",\n          name: \"Tether USD\",\n          balance: 0,\n          decimals: 6,\n          mintAddress: \"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB\",\n          icon: \"/crypto-logos/tether-usdt-logo.svg\",\n        }\n      ];\n\n      // Fetch SPL tokens using the provider connection\n      const splTokens: TokenInfo[] = [];\n\n      try {\n        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(\n          ownerPublicKey,\n          {\n            programId: new PublicKey(\n              \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n            ),\n          }\n        );\n\n        for (const account of tokenAccounts.value) {\n          const accountData = account.account.data.parsed.info;\n          const mintAddress = accountData.mint;\n          const tokenAmount = accountData.tokenAmount;\n\n          if (tokenAmount.uiAmount > 0) {\n            // Only include tokens with non-zero balance\n            splTokens.push({\n              id: mintAddress,\n              symbol: mintAddress.substring(0, 4) + \"...\", // Use shortened mint as symbol if no metadata\n              name: \"Token \" + mintAddress.substring(0, 6), // Use shortened mint as name if no metadata\n              balance: tokenAmount.uiAmount,\n              decimals: tokenAmount.decimals,\n              mintAddress: mintAddress,\n            });\n          }\n        }\n      } catch (error) {\n        console.error(\"Error fetching SPL token accounts:\", error);\n      }\n\n      // Return combined tokens\n      return [...defaultTokens, ...splTokens];\n    } catch (error) {\n      console.error(\"Error fetching token accounts:\", error);\n      // Return basic SOL token on error\n      return [\n        {\n          id: \"sol\",\n          symbol: \"SOL\",\n          name: \"Solana\",\n          balance: 0,\n          decimals: 9,\n          icon: \"/crypto-logos/solana-logo.svg\",\n        },\n      ];\n    } finally {\n      setIsLoadingTokens(false);\n    }\n  };\n\n  // Load tokens effect\n  useEffect(() => {\n    // If tokens are provided as props, use those\n    if (tokens) {\n      setAvailableTokens(tokens);\n    }\n    // Otherwise, if wallet is connected, fetch tokens\n    else if (connected && publicKey) {\n      fetchTokenAccounts(publicKey)\n        .then((fetchedTokens) => {\n          setAvailableTokens(fetchedTokens);\n        })\n        .catch((error) => {\n          console.error(\"Error setting tokens:\", error);\n          // Set default SOL token on error\n          setAvailableTokens([\n            {\n              id: \"sol\",\n              symbol: \"SOL\",\n              name: \"Solana\",\n              balance: 0,\n              decimals: 9,\n              icon: \"/crypto-logos/solana-logo.svg\",\n            },\n          ]);\n        });\n    }\n  }, [tokens, connected, publicKey]);\n\n  // Handle use max amount\n  const handleUseMax = (e?: React.MouseEvent) => {\n    // Prevent form submit event if there is an event\n    if (e) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n    \n    if (selectedTokenIn && selectedTokenIn.balance > 0) {\n      // If SOL is selected, keep 0.01 SOL for transaction fees\n      let maxAmount: number;\n      \n      if (selectedTokenIn.id === \"sol\" || \n          selectedTokenIn.mintAddress === \"So11111111111111111111111111111111111111112\") {\n        // Keep 0.05 SOL for transaction fees, enough for most transactions\n        maxAmount = Math.max(selectedTokenIn.balance - 0.05, 0);\n      } else {\n        maxAmount = selectedTokenIn.balance;\n      }\n      \n      setAmountInValue(maxAmount.toString());\n      form.setValue(\"amountIn\", maxAmount, {\n        shouldValidate: false,\n        shouldDirty: true,\n        shouldTouch: true,\n      });\n      \n      // If the output token is selected, wait a bit before getting the quote\n      if (selectedTokenOut && maxAmount > 0) {\n        setTimeout(() => {\n          fetchSwapQuote(maxAmount, true);\n        }, 0);\n      }\n    }\n  };\n\n  // Handle amount input change with debounce\n  const handleAmountInChange = (value: string) => {\n    setAmountInValue(value);\n    const parsedValue = value === \"\" ? undefined : parseFloat(value);\n    form.setValue(\"amountIn\", parsedValue, {\n      shouldValidate: false  // Prevent validation\n    });\n    \n    if (!parsedValue || parsedValue <= 0) {\n      setAmountOutValue(\"\");\n      setQuoteResult(null);\n      return;\n    }\n\n    // Cancel old timeout if any\n    if (inputTimeout) {\n      clearTimeout(inputTimeout);\n    }\n    \n    // Automatically update the quote after the user stops typing for 500ms\n    if (parsedValue && parsedValue > 0 && selectedTokenIn && selectedTokenOut) {\n      const newTimeout = setTimeout(() => {\n        fetchSwapQuote(parsedValue, false);\n      }, 500);\n      \n      setInputTimeout(newTimeout);\n    }\n  };\n\n  // Add blur event handler to ensure update when user loses focus\n  const handleAmountInBlur = () => {\n    if (amountInValue && parseFloat(amountInValue) > 0 && selectedTokenIn && selectedTokenOut) {\n      fetchSwapQuote(parseFloat(amountInValue), false);\n    }\n  };\n\n  // Handle token change\n  const handleTokenChange = (isInput: boolean, tokenId: string) => {\n    const token = availableTokens.find((t) => t.id === tokenId);\n    \n    if (!token) return;\n    \n    if (isInput) {\n      if (selectedTokenOut && token.id === selectedTokenOut.id) {\n        toast.error(\"Cannot select the same token\", {\n          description: \"Please select different tokens for input and output\",\n        });\n        return;\n      }\n      \n      setSelectedTokenIn(token);\n      form.setValue(\"tokenIn\", token.id, {\n        shouldValidate: false  // Prevent validation\n      });\n    } else {\n      if (selectedTokenIn && token.id === selectedTokenIn.id) {\n        toast.error(\"Cannot select the same token\", {\n          description: \"Please select different tokens for input and output\",\n        });\n        return;\n      }\n      \n      setSelectedTokenOut(token);\n      form.setValue(\"tokenOut\", token.id, {\n        shouldValidate: false  // Prevent validation\n      });\n    }\n    \n    // Clear amounts and re-quote if we have an input amount\n    if (amountInValue && parseFloat(amountInValue) > 0) {\n      fetchSwapQuote(parseFloat(amountInValue), false);\n    }\n  };\n\n  // Handle slippage change\n  const handleSlippageChange = (value: number) => {\n    setSlippageValue(value);\n    form.setValue(\"slippage\", value, {\n      shouldValidate: false  // Prevent validation\n    });\n  };\n\n  // Switch tokens\n  const handleSwitchTokens = () => {\n    // Swap token selections\n    const tempTokenIn = selectedTokenIn;\n    const tempTokenOut = selectedTokenOut;\n    \n    setSelectedTokenIn(tempTokenOut);\n    setSelectedTokenOut(tempTokenIn);\n    \n    if (tempTokenOut) {\n      form.setValue(\"tokenIn\", tempTokenOut.id, {\n        shouldValidate: false  // Prevent validation\n      });\n    }\n    \n    if (tempTokenIn) {\n      form.setValue(\"tokenOut\", tempTokenIn.id, {\n        shouldValidate: false  // Prevent validation\n      });\n    }\n    \n    // Clear amounts and re-quote if needed\n    setAmountInValue(\"\");\n    setAmountOutValue(\"\");\n    form.setValue(\"amountIn\", undefined, {\n      shouldValidate: false  // Prevent validation\n    });\n    form.setValue(\"amountOut\", undefined, {\n      shouldValidate: false  // Prevent validation\n    });\n    setQuoteResult(null);\n  };\n\n  // Fetch swap quote\n  const fetchSwapQuote = async (amount: number, isFromMaxButton: boolean = false) => {\n    if (!connected || !publicKey) {\n      toast.error(\"Wallet not connected\", { \n        description: \"Please connect your wallet to get a quote\" \n      });\n      return;\n    }\n  \n    if (!selectedTokenIn || !selectedTokenOut) {\n      toast.error(\"Select tokens\", { \n        description: \"Please select input and output tokens\" \n      });\n      return;\n    }\n  \n    if (amount <= 0) {\n      setAmountOutValue(\"\");\n      setQuoteResult(null);\n      return;\n    }\n  \n    try {\n      setIsLoadingQuote(true);\n  \n      // Check token address\n      if (!selectedTokenIn.mintAddress || !selectedTokenOut.mintAddress) {\n        throw new Error(\"Token mintAddress not found\");\n      }\n\n      // Create PublicKey from address\n      const inputMint = new PublicKey(selectedTokenIn.mintAddress);\n      const outputMint = new PublicKey(selectedTokenOut.mintAddress);\n      const slippageBps = Math.floor(slippageValue * 100);\n      \n      // Call API to get quote\n      const quoteResponse = await getQuote(\n        outputMint,\n        amount,\n        inputMint,\n        slippageBps\n      );\n  \n      if (quoteResponse) {\n        // Update state with result from API\n        setQuoteResult(quoteResponse);\n        setAmountOutValue(quoteResponse.outputAmount);\n        form.setValue(\"amountOut\", Number(quoteResponse.outputAmount), {\n          shouldValidate: false\n        });\n      } else {\n        setQuoteResult(null);\n        setAmountOutValue(\"\");\n        form.setValue(\"amountOut\", undefined, {\n          shouldValidate: false\n        });\n      }\n    } catch (error: any) {\n      setQuoteResult(null);\n      setAmountOutValue(\"\");\n      toast.error(\"Failed to get quote\", {\n        description: error?.message || \"Unable to fetch quote from Jupiter\"\n      });\n    } finally {\n      setIsLoadingQuote(false);\n    }\n  };\n\n  // Handle form submission\n  const onSubmit = async (values: SwapFormValues) => {\n    if (!connected) {\n      toast.error(\"Wallet not connected\");\n      return;\n    }\n\n    if (!publicKey) {\n      toast.error(\"Public key not found\");\n      return;\n    }\n\n    if (!connection) {\n      toast.error(\"Invalid connection\");\n      return;\n    }\n\n    if (!endpoint) {\n      toast.error(\"RPC endpoint not found\");\n      return;\n    }\n\n    if (!selectedTokenIn || !selectedTokenOut) {\n      toast.error(\"Select tokens\");\n      return;\n    }\n\n    if (!values.amountIn || values.amountIn <= 0) {\n      toast.error(\"Invalid amount\");\n      return;\n    }\n\n    try {\n      setIsSubmitting(true);\n      \n      // Check token address\n      if (!selectedTokenIn.mintAddress || !selectedTokenOut.mintAddress) {\n        throw new Error(\"Token mintAddress not found\");\n      }\n      \n      // Create PublicKey from address\n      const inputMint = new PublicKey(selectedTokenIn.mintAddress);\n      const outputMint = new PublicKey(selectedTokenOut.mintAddress);\n      const slippageBps = Math.floor(slippageValue * 100);\n      \n      // Log transaction information for debugging\n      console.log(\"=== Transaction Information ===\");\n      console.log(\"Endpoint:\", endpoint);\n      console.log(\"Input token:\", selectedTokenIn.symbol, inputMint.toString());\n      console.log(\"Output token:\", selectedTokenOut.symbol, outputMint.toString());\n      console.log(\"Amount:\", values.amountIn);\n      console.log(\"Slippage:\", slippageBps, \"bps\");\n      console.log(\"Wallet connected:\", connected ? \"Yes\" : \"No\");\n      console.log(\"PublicKey:\", publicKey.toString());\n      console.log(\"========================\");\n      \n      // Check all parameters before executing the transaction\n      if (!wallet) {\n        throw new Error(\"Wallet not connected\");\n      }\n      \n      try {\n        // Execute the swap transaction with proper validation\n        console.log(\"Calling executeTrade with parameters:\");\n        console.log(\" - outputMint:\", outputMint.toString());\n        console.log(\" - inputAmount:\", values.amountIn);\n        console.log(\" - inputMint:\", inputMint.toString());\n        console.log(\" - slippageBps:\", slippageBps);\n        console.log(\" - wallet:\", typeof wallet, wallet ? \"connected\" : \"not connected\");\n        \n        // Check if wallet supports signTransaction method\n        const walletAdapter = wallet as any;\n        console.log(\" - wallet supports signTransaction:\", walletAdapter?.signTransaction ? \"yes\" : \"no\");\n        console.log(\" - endpoint:\", endpoint);\n\n        // Pass fewer parameters, compatible with new API\n        const signature = await executeTrade(\n          outputMint,\n          values.amountIn,\n          inputMint,\n          slippageBps\n        );\n  \n        toast.success(\"Swap successful!\", {\n          description: `Transaction: ${signature}`\n        });\n  \n        // Reset form and update balances\n        setAmountInValue(\"\");\n        setAmountOutValue(\"\");\n        form.setValue(\"amountIn\", undefined, {\n          shouldValidate: false\n        });\n        form.setValue(\"amountOut\", undefined, {\n          shouldValidate: false\n        });\n        setQuoteResult(null);\n  \n        // Update balances after successful swap\n        if (publicKey) {\n          await updateBalances();\n        }\n      } catch (tradeError: any) {\n        console.error(\"Trade execution error:\", tradeError);\n        toast.error(\"Transaction failed\", {\n          description: tradeError.message || \"Unable to execute transaction\"\n        });\n      }\n    } catch (error: any) {\n      console.error(\"Swap error:\", error);\n      toast.error(\"Swap failed\", {\n        description: error.message || \"Transaction failed\"\n      });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // Separate function to update balances\n  const updateSelectedTokenBalances = (updatedTokens: TokenInfo[]) => {\n    // Update selected token balances if they exist in the updated tokens list\n    if (selectedTokenIn) {\n      const updatedTokenIn = updatedTokens.find(t => t.id === selectedTokenIn.id);\n      if (updatedTokenIn) {\n        setSelectedTokenIn(updatedTokenIn);\n      }\n    }\n    \n    if (selectedTokenOut) {\n      const updatedTokenOut = updatedTokens.find(t => t.id === selectedTokenOut.id);\n      if (updatedTokenOut) {\n        setSelectedTokenOut(updatedTokenOut);\n      }\n    }\n  };\n\n  // Existing updateBalances function remains the same\n  const updateBalances = async () => {\n    setIsUpdatingBalance(true);\n    try {\n      const updatedTokens = await fetchTokenAccounts(publicKey!);\n      setAvailableTokens(updatedTokens);\n      updateSelectedTokenBalances(updatedTokens);\n      toast.success(\"Balances updated\");\n    } catch (error) {\n      console.error(\"Error updating balances:\", error);\n    } finally {\n      setIsUpdatingBalance(false);\n    }\n  };\n\n  // Render token item for the select dropdown\n  const renderTokenItem = (token: TokenInfo) => (\n    <SelectItem key={token.id} value={token.id}>\n      <div className=\"flex items-center justify-between w-full\">\n        <div className=\"flex items-center\">\n          {token.icon && (\n            <div className=\"w-5 h-5 mr-2 rounded-full overflow-hidden flex items-center justify-center\">\n              <img\n                src={token.icon || \"/placeholder.svg\"}\n                alt={token.symbol}\n                className=\"w-4 h-4 object-contain\"\n                onError={(e) => {\n                  (e.target as HTMLImageElement).style.display = \"none\";\n                }}\n              />\n            </div>\n          )}\n          <span>{token.symbol}</span>\n        </div>\n        {showTokenBalance && (\n          <span className=\"text-muted-foreground ml-2 text-sm\">\n            {token.balance.toLocaleString(undefined, {\n              minimumFractionDigits: 0,\n              maximumFractionDigits: token.decimals > 6 ? 6 : token.decimals,\n            })}\n          </span>\n        )}\n      </div>\n    </SelectItem>\n  );\n\n  return (\n    <Card className={className}>\n      <CardHeader>\n        <CardTitle className=\"flex items-center justify-between\">\n          <span>Swap Tokens</span>\n          <Popover open={slippageSettingsOpen} onOpenChange={setSlippageSettingsOpen}>\n            <PopoverTrigger asChild>\n              <Button variant=\"ghost\" size=\"icon\">\n                <Settings className=\"h-5 w-5\" />\n              </Button>\n            </PopoverTrigger>\n            <PopoverContent className=\"w-80\">\n              <div className=\"space-y-4\">\n                <h4 className=\"font-medium\">Slippage Tolerance</h4>\n                <div className=\"flex items-center justify-between gap-2\">\n                  <Button \n                    variant={slippageValue === 0.1 ? \"default\" : \"outline\"} \n                    size=\"sm\"\n                    onClick={() => handleSlippageChange(0.1)}\n                    className=\"flex-1\"\n                  >\n                    0.1%\n                  </Button>\n                  <Button \n                    variant={slippageValue === 0.5 ? \"default\" : \"outline\"} \n                    size=\"sm\"\n                    onClick={() => handleSlippageChange(0.5)}\n                    className=\"flex-1\"\n                  >\n                    0.5%\n                  </Button>\n                  <Button \n                    variant={slippageValue === 1 ? \"default\" : \"outline\"} \n                    size=\"sm\"\n                    onClick={() => handleSlippageChange(1)}\n                    className=\"flex-1\"\n                  >\n                    1.0%\n                  </Button>\n                </div>\n                <div className=\"space-y-2\">\n                  <div className=\"flex justify-between\">\n                    <span>Custom: {slippageValue.toFixed(1)}%</span>\n                  </div>\n                  <Slider\n                    value={[slippageValue]}\n                    min={0.1}\n                    max={5}\n                    step={0.1}\n                    onValueChange={(value) => handleSlippageChange(value[0])}\n                  />\n                  {slippageValue > 3 && (\n                    <p className=\"text-yellow-500 text-sm\">\n                      High slippage increases the risk of price impact\n                    </p>\n                  )}\n                </div>\n              </div>\n            </PopoverContent>\n          </Popover>\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        <Form {...form}>\n          <form \n            onSubmit={(e) => {\n              // Check if clicking MAX button then do not submit\n              const target = e.target as HTMLElement;\n              const maxButton = target.querySelector('.max-button');\n              if (maxButton && (maxButton === document.activeElement || maxButton.contains(document.activeElement as Node))) {\n                e.preventDefault();\n                return;\n              }\n              \n              e.preventDefault();\n              form.handleSubmit(onSubmit)(e);\n            }}\n            className=\"space-y-4\"\n          >\n            {/* Token Input Field */}\n            <div className=\"space-y-2\">\n              <FormField\n                control={form.control}\n                name=\"tokenIn\"\n                render={({ field }) => (\n                  <FormItem className=\"bg-secondary/50 rounded-lg p-4\">\n                    <div className=\"flex justify-between items-center\">\n                      <FormLabel>You Pay</FormLabel>\n                      {selectedTokenIn && showTokenBalance && (\n                        <div className=\"flex items-center text-xs text-muted-foreground space-x-1\">\n                          <span>\n                            Balance: {selectedTokenIn.balance.toLocaleString(undefined, {\n                              minimumFractionDigits: 0,\n                              maximumFractionDigits: selectedTokenIn.decimals > 6 ? 6 : selectedTokenIn.decimals,\n                            })}\n                          </span>\n                          <div className=\"max-button-container\" onClick={(e) => e.stopPropagation()}>\n                            <span \n                              className=\"cursor-pointer h-auto py-0 px-2 text-xs text-primary hover:underline max-button\" \n                              onClick={(e) => {\n                                e.preventDefault();\n                                e.stopPropagation();\n                                handleUseMax();\n                              }}\n                            >\n                              MAX\n                            </span>\n                          </div>\n                        </div>\n                      )}\n                    </div>\n                    <div className=\"flex items-center space-x-2 mt-2\">\n                      <FormControl>\n                        <Input\n                          type=\"number\"\n                          placeholder=\"0.0\"\n                          step=\"any\"\n                          value={amountInValue}\n                          onChange={(e) => handleAmountInChange(e.target.value)}\n                          onBlur={handleAmountInBlur}\n                          disabled={!connected || !selectedTokenIn}\n                          className=\"bg-transparent border-none text-xl font-medium placeholder:text-muted-foreground focus-visible:ring-0 focus-visible:ring-offset-0\"\n                        />\n                      </FormControl>\n                      <Select\n                        onValueChange={(value) => handleTokenChange(true, value)}\n                        value={field.value}\n                        disabled={!connected}\n                      >\n                        <FormControl>\n                          <SelectTrigger className=\"min-w-[140px] h-auto bg-background\">\n                            <SelectValue\n                              placeholder={\n                                isLoadingTokens || isUpdatingBalance\n                                  ? \"Loading...\"\n                                  : \"Select\"\n                              }\n                            >\n                              {selectedTokenIn && (\n                                <div className=\"flex items-center\">\n                                  {selectedTokenIn.icon && (\n                                    <img\n                                      src={selectedTokenIn.icon}\n                                      alt={selectedTokenIn.symbol}\n                                      className=\"w-5 h-5 mr-2 rounded-full\"\n                                    />\n                                  )}\n                                  {selectedTokenIn.symbol}\n                                </div>\n                              )}\n                            </SelectValue>\n                          </SelectTrigger>\n                        </FormControl>\n                        <SelectContent>\n                          {isLoadingTokens || isUpdatingBalance ? (\n                            <div className=\"flex items-center justify-center p-2\">\n                              <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\n                              <span>\n                                {isUpdatingBalance\n                                  ? \"Updating balances...\"\n                                  : \"Loading tokens...\"}\n                              </span>\n                            </div>\n                          ) : availableTokens.length > 0 ? (\n                            <SelectGroup>\n                              {availableTokens.map(renderTokenItem)}\n                            </SelectGroup>\n                          ) : (\n                            <div className=\"p-2 text-muted-foreground text-center\">\n                              No tokens found\n                            </div>\n                          )}\n                        </SelectContent>\n                      </Select>\n                    </div>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              \n              {/* Arrow button to switch tokens */}\n              <div className=\"flex justify-center -my-2 relative z-10\">\n                <Button\n                  variant=\"outline\"\n                  size=\"icon\"\n                  className=\"rounded-full h-10 w-10 bg-background border-background shadow-md\"\n                  onClick={handleSwitchTokens}\n                  disabled={!selectedTokenIn || !selectedTokenOut}\n                >\n                  <ArrowDown className=\"h-4 w-4\" />\n                </Button>\n              </div>\n\n              {/* Token Output Field */}\n              <FormField\n                control={form.control}\n                name=\"tokenOut\"\n                render={({ field }) => (\n                  <FormItem className=\"bg-secondary/50 rounded-lg p-4\">\n                    <div className=\"flex justify-between items-center\">\n                      <FormLabel>You Receive</FormLabel>\n                      {selectedTokenOut && showTokenBalance && (\n                        <div className=\"text-xs text-muted-foreground\">\n                          Balance: {selectedTokenOut.balance.toLocaleString(undefined, {\n                            minimumFractionDigits: 0,\n                            maximumFractionDigits: selectedTokenOut.decimals > 6 ? 6 : selectedTokenOut.decimals,\n                          })}\n                        </div>\n                      )}\n                    </div>\n                    <div className=\"flex items-center space-x-2 mt-2\">\n                      <FormControl>\n                        <Input\n                          type=\"text\"\n                          placeholder=\"0.0\"\n                          value={amountOutValue}\n                          disabled={true} // Always disabled - calculated from input\n                          className=\"bg-transparent border-none text-xl font-medium placeholder:text-muted-foreground focus-visible:ring-0 focus-visible:ring-offset-0\"\n                        />\n                      </FormControl>\n                      <Select\n                        onValueChange={(value) => handleTokenChange(false, value)}\n                        value={field.value}\n                        disabled={!connected}\n                      >\n                        <FormControl>\n                          <SelectTrigger className=\"min-w-[140px] h-auto bg-background\">\n                            <SelectValue\n                              placeholder={\n                                isLoadingTokens || isUpdatingBalance\n                                  ? \"Loading...\"\n                                  : \"Select\"\n                              }\n                            >\n                              {selectedTokenOut && (\n                                <div className=\"flex items-center\">\n                                  {selectedTokenOut.icon && (\n                                    <img\n                                      src={selectedTokenOut.icon}\n                                      alt={selectedTokenOut.symbol}\n                                      className=\"w-5 h-5 mr-2 rounded-full\"\n                                    />\n                                  )}\n                                  {selectedTokenOut.symbol}\n                                </div>\n                              )}\n                            </SelectValue>\n                          </SelectTrigger>\n                        </FormControl>\n                        <SelectContent>\n                          {isLoadingTokens || isUpdatingBalance ? (\n                            <div className=\"flex items-center justify-center p-2\">\n                              <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\n                              <span>\n                                {isUpdatingBalance\n                                  ? \"Updating balances...\"\n                                  : \"Loading tokens...\"}\n                              </span>\n                            </div>\n                          ) : availableTokens.length > 0 ? (\n                            <SelectGroup>\n                              {availableTokens.map(renderTokenItem)}\n                            </SelectGroup>\n                          ) : (\n                            <div className=\"p-2 text-muted-foreground text-center\">\n                              No tokens found\n                            </div>\n                          )}\n                        </SelectContent>\n                      </Select>\n                    </div>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n            </div>\n            {/* Add swap button section */}\n            <div className=\"pt-2\">\n              {!connected ? (\n                <ConnectWalletButton className=\"w-full\" />\n              ) : (\n                <Button\n                  type=\"submit\"\n                  className=\"w-full\"\n                  disabled={\n                    isSubmitting ||\n                    isLoading ||\n                    !selectedTokenIn ||\n                    !selectedTokenOut ||\n                    !amountInValue ||\n                    parseFloat\n                    (amountInValue) <= 0 || \n                    isLoadingQuote\n                  }\n                  >\n                  {isSubmitting || isLoading? (\n                    <>\n                    <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\n                    Swapping...\n                    </>\n                  ) : (\n                    \"Swap\"\n                  )}\n                  </Button>\n                )}\n            </div>\n\n\n            {/*/ Add exchange rate info if quote exists */}\n            {quoteResult && (\n              <div className=\"space-y-1\">\n                <div className=\"text-sm text-muted-foreground text-center\">\n                  1 {selectedTokenIn?.symbol} â‰ˆ {quoteResult.exchangeRate.toLocaleString(undefined, {\n                    minimumFractionDigits: 2,\n                    maximumFractionDigits: 6\n                  })} {selectedTokenOut?.symbol}\n                </div>\n                <div className=\"text-xs text-center flex justify-center gap-2\">\n                  <span className=\"text-muted-foreground\">\n                    Slippage: {slippageValue.toFixed(1)}%\n                  </span>\n                  {quoteResult.priceImpactPct > 1 && (\n                    <span className={`${quoteResult.priceImpactPct > 3 ? 'text-red-500' : 'text-yellow-500'}`}>\n                      Price impact: {quoteResult.priceImpactPct.toFixed(2)}%\n                    </span>\n                  )}\n                </div>\n              </div>\n            )}\n          </form>\n        </Form>\n      </CardContent>\n    </Card>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/ui/murphis/swap-token-form.tsx"
    },
    {
      "path": "hook/murphis/use-JupiterTrade.ts",
      "content": "import { VersionedTransaction, PublicKey, Connection } from \"@solana/web3.js\";\nimport {\n  TOKENS,\n  DEFAULT_OPTIONS,\n  JUP_API,\n  JUP_REFERRAL_ADDRESS,\n} from \"../../constants/swap/jupiter-constants\";\nimport { getMint, getAccount, getAssociatedTokenAddress, TokenAccountNotFoundError, TokenInvalidAccountOwnerError } from \"@solana/spl-token\";\nimport { useWallet, WalletContextState } from \"@solana/wallet-adapter-react\";\nimport { config } from \"../../config/swap\";\nimport { useContext } from \"react\";\nimport { ModalContext } from \"@/components/providers/wallet-provider\";\n\n/**\n * Interface for quote result from Jupiter\n */\nexport interface QuoteResponse {\n  inputMint: string;\n  outputMint: string;\n  amount: string;\n  otherAmountThreshold: string;\n  swapMode: string;\n  slippageBps: number;\n  platformFee?: {\n    amount: string;\n    feeBps: number;\n  };\n  priceImpactPct: number;\n  routePlan: any[];\n  contextSlot: number;\n  timeTaken: number;\n  outAmount: string;\n  outAmountWithSlippage?: string;\n}\n\n/**\n * Get swap quote from Jupiter API\n * @param inputMint Mint address of input token\n * @param outputMint Mint address of output token\n * @param amount Amount of input token (scaled by decimals)\n * @param slippageBps Maximum slippage tolerance (basis points)\n * @returns Quote result\n */\nexport async function fetchQuote(\n  outputMint: PublicKey,\n  amount: number | string,\n  inputMint: PublicKey,\n  slippageBps: number = DEFAULT_OPTIONS.SLIPPAGE_BPS,\n  useDynamicSlippage: boolean = false\n): Promise<any> {\n  try {\n    // Convert amount to string to avoid issues with large numbers\n    const amountStr = amount.toString();\n    \n    console.log(`fetchQuote: inputMint=${inputMint.toString()}, outputMint=${outputMint.toString()}, amount=${amountStr}`);\n    \n    // Validate parameters\n    if (!inputMint || !outputMint || !amount || parseFloat(amountStr) <= 0) {\n      throw new Error(\"Invalid quote parameters\");\n    }\n    \n    // Check if input token is native SOL\n    const isNativeSol = inputMint.equals(TOKENS.SOL);\n    \n    const apiUrl = `${JUP_API}/quote?` +\n      `inputMint=${isNativeSol ? TOKENS.SOL.toString() : inputMint.toString()}` +\n      `&outputMint=${outputMint.toString()}` +\n      `&amount=${amountStr}` +\n      `&slippageBps=${slippageBps}` +\n      `&minimizeSlippage=false` +\n      `&onlyDirectRoutes=false` +\n      `&maxAccounts=64` +\n      `&swapMode=ExactIn`;\n    \n    console.log(`Sending API request: ${apiUrl}`);\n    \n    const response = await fetch(apiUrl, {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n      },\n      mode: 'cors',\n    });\n    \n    // Check for HTTP errors\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(`Jupiter API error (${response.status}): ${errorText}`);\n      \n      if (response.status === 400) {\n        throw new Error(`Unable to get quote: Invalid token amount or insufficient liquidity (${response.status})`);\n      } else if (response.status === 429) {\n        throw new Error(\"Too many requests, please try again later\");\n      } else {\n        throw new Error(`API error: ${response.status} - ${errorText || 'No error information'}`);\n      }\n    }\n    \n    const quoteResponse = await response.json();\n    \n    // Check if data is valid\n    if (!quoteResponse) {\n      console.error(\"Invalid quote data:\", quoteResponse);\n      throw new Error(\"Invalid quote data\");\n    }\n    \n    console.log(\"Received quote:\", quoteResponse);\n    return quoteResponse;\n  } catch (error: any) {\n    console.error(\"Error fetching quote:\", error);\n    throw new Error(`Unable to fetch quote: ${error.message || 'Unknown error'}`);\n  }\n}\n\n/**\n * Scale token amount by decimals\n * @param amount Token amount (user input)\n * @param decimals Token decimals\n */\nexport function scaleAmount(amount: number, decimals: number): number {\n  return amount * Math.pow(10, decimals);\n}\n\n/**\n * Format token amount from lamports to decimals\n * @param amount Token amount (in lamports)\n * @param decimals Token decimals\n */\nexport function formatAmount(amount: string | number, decimals: number): string {\n  try {\n    // Convert amount to string if it's a number\n    const amountStr = typeof amount === 'number' ? amount.toString() : amount;\n    \n    // Convert to BigInt for precise handling of large numbers\n    const amountBigInt = BigInt(amountStr);\n    \n    // Check if amount is zero\n    if (amountBigInt === BigInt(0)) {\n      return '0';\n    }\n    \n    const divisor = BigInt(10 ** decimals);\n    \n    // Calculate whole part\n    const wholePart = amountBigInt / divisor;\n    \n    // Calculate fractional part\n    const fractionalPart = amountBigInt % divisor;\n    \n    // Format fractional part\n    let fractionalStr = fractionalPart.toString().padStart(decimals, '0');\n    \n    // For SOL and very small amounts, ensure we show enough decimal places\n    if (decimals === 9 && wholePart === BigInt(0) && fractionalPart > BigInt(0)) {\n      // Format with fixed decimal places for visibility\n      const formattedNumber = Number(amountBigInt) / Number(divisor);\n      console.log(`Formatting small SOL amount: ${formattedNumber}`);\n      \n      // Ensure we display at least 4 significant digits\n      // For 0.006, this would show 0.006 (not rounded)\n      return formattedNumber.toFixed(Math.max(3, decimals.toString().length));\n    }\n    \n    // Normal formatting for larger amounts\n    // Remove trailing zeros but keep at least one decimal for small values\n    const trimmedFractional = fractionalStr.replace(/0+$/, '');\n    \n    // If whole part is 0 and fractional part exists but would be trimmed to empty,\n    // keep at least 4 decimal places to show small values\n    if (wholePart === BigInt(0) && fractionalPart > BigInt(0) && trimmedFractional === '') {\n      // Find first non-zero digit\n      let significantDigits = 0;\n      for (let i = 0; i < fractionalStr.length; i++) {\n        if (fractionalStr[i] !== '0') {\n          significantDigits = i;\n          break;\n        }\n      }\n      // Show at least the first non-zero digit and a few more\n      const digitsToShow = Math.min(significantDigits + 3, fractionalStr.length);\n      fractionalStr = fractionalStr.substring(0, digitsToShow);\n    } else {\n      fractionalStr = trimmedFractional;\n    }\n    \n    // If no fractional part, return only whole part\n    if (fractionalStr === '') {\n      return wholePart.toString();\n    }\n    \n    // Combine whole and fractional parts\n    return `${wholePart.toString()}.${fractionalStr}`;\n  } catch (error) {\n    console.error(\"Error formatting token amount:\", error);\n    return '0';\n  }\n}\n\n// Hardcoded decimals for common tokens to avoid errors when querying blockchain\nconst TOKEN_DECIMALS: { [key: string]: number } = {\n  // USDC\n  'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 6,\n  // USDT\n  'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': 6,\n  // SOL (wrapped)\n  'So11111111111111111111111111111111111111112': 9,\n  // BONK\n  'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': 5,\n  // jitoSOL\n  'J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn': 9,\n  // bSOL\n  'bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1': 9,\n  // mSOL\n  'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So': 9,\n  // USDS\n  'USDSwr9ApdHk5bvJKMjzff41FfuX8bSxdKcR81vTwcA': 6,\n};\n\n/**\n * Function to get the decimals of a token by mint address\n */\nconst getTokenDecimals = (mintAddress: string): number => {\n  // Use value from TOKEN_DECIMALS if available\n  if (TOKEN_DECIMALS[mintAddress]) {\n    return TOKEN_DECIMALS[mintAddress];\n  }\n  \n  // Default value if not found\n  console.warn(`Decimals for token ${mintAddress} not found, using default 6`);\n  return 6;\n};\n\n/**\n * Solana blockchain token swap function, using Jupiter API\n */\nconst trade = async (\n  outputMint: PublicKey,\n  inputAmount: number,\n  inputMint: PublicKey = TOKENS.USDC,\n  slippageBps: number = DEFAULT_OPTIONS.SLIPPAGE_BPS,\n  walletPublicKey: string, \n  wallet: any,\n  connectionEndpoint: string\n) => {\n  try {\n    // Check if all necessary parameters are provided\n    if (!connectionEndpoint) {\n      throw new Error(\"Connection endpoint is not defined\");\n    }\n    \n    if (!walletPublicKey) {\n      throw new Error(\"Wallet public key is not defined\");\n    }\n    \n    if (!wallet) {\n      throw new Error(\"Wallet is not defined\");\n    }\n    \n    // Check if wallet has signTransaction function\n    console.log(\"Checking wallet before trade:\", {\n      walletType: typeof wallet,\n      hasSignTransaction: typeof wallet.signTransaction === 'function'\n    });\n    \n    if (typeof wallet.signTransaction !== 'function') {\n      throw new Error(\"Wallet does not have signTransaction method\");\n    }\n    \n    // Create connection to Solana blockchain\n    const connection = new Connection(connectionEndpoint, {\n      commitment: 'confirmed',\n      confirmTransactionInitialTimeout: 60000\n    });\n\n    // Display transaction information\n    console.log(`Executing swap with slippage ${slippageBps / 100}%`);\n    console.log(\"Input token decimal:\", getTokenDecimals(inputMint.toString()));\n    console.log(\"Output token decimal:\", getTokenDecimals(outputMint.toString()));\n    \n    // Adjust calculation of scaledAmount to only take the integer part\n    const inputDecimals = getTokenDecimals(inputMint.toString());\n    const scaledAmount = Math.floor(inputAmount * Math.pow(10, inputDecimals));\n    console.log(\"Scaled amount:\", scaledAmount);\n\n    // Get quote from Jupiter API\n    const quoteResponse = await fetch(\n      `${JUP_API}/quote?inputMint=${inputMint.toString()}&outputMint=${outputMint.toString()}&amount=${scaledAmount}&slippageBps=${slippageBps}`,\n      {\n        method: \"GET\",\n      }\n    );\n\n    if (!quoteResponse.ok) {\n      const errorText = await quoteResponse.text();\n      console.error(`Jupiter API error (${quoteResponse.status}): ${errorText}`);\n      \n      if (quoteResponse.status === 400) {\n        throw new Error(`Unable to get quote: Invalid token amount or insufficient liquidity (${quoteResponse.status}) - ${errorText}`);\n      } else if (quoteResponse.status === 429) {\n        throw new Error(\"Too many requests, please try again later\");\n      } else {\n        throw new Error(`API error: ${quoteResponse.status} - ${errorText || 'No error information'}`);\n      }\n    }\n\n    const quote = await quoteResponse.json();\n    console.log(\"Quote response:\", quote);\n    \n    // Set up referral fee if available\n    const jupiterReferralAccount = process.env.NEXT_PUBLIC_JUPITER_REFERRAL_ACCOUNT;\n    const referralAccount = jupiterReferralAccount ? new PublicKey(jupiterReferralAccount) : undefined;\n\n    // Execute swap\n    const swapResponse = await fetch(`${JUP_API}/swap`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        quoteResponse: quote,\n        userPublicKey: walletPublicKey,\n        feeAccount: referralAccount?.toString(),\n        wrapAndUnwrapSol: true,\n      }),\n    });\n\n    if (!swapResponse.ok) {\n      throw new Error(`Error executing swap: ${swapResponse.status} ${swapResponse.statusText}`);\n    }\n\n    const swapResult = await swapResponse.json();\n    console.log(\"Swap result:\", swapResult);\n\n    // Decode transaction\n    const swapTransaction = VersionedTransaction.deserialize(\n      Buffer.from(swapResult.swapTransaction, \"base64\")\n    );\n\n    // Sign and send transaction\n    try {\n      console.log(\"Signing transaction with wallet:\", typeof wallet.signTransaction);\n      const signedTransaction = await wallet.signTransaction(swapTransaction);\n      console.log(\"Transaction successfully signed\");\n      \n      const txid = await connection.sendRawTransaction(\n        signedTransaction.serialize()\n      );\n      console.log(\"Transaction sent. Txid:\", txid);\n      \n      console.log(\"Waiting for transaction confirmation...\");\n      const confirmation = await connection.confirmTransaction(txid, \"confirmed\");\n      console.log(\"Transaction confirmed:\", confirmation);\n      \n      return { success: true, txid };\n    } catch (error: any) {\n      console.error(\"Error signing or sending transaction:\", error);\n      throw new Error(`Error signing or sending transaction: ${error.message}`);\n    }\n  } catch (error: any) {\n    console.error(\"Error during trade execution:\", error);\n    throw error;\n  }\n};\n\n/**\n * Get token balance for a wallet address\n * @param walletAddress Wallet address to check balance for\n * @param tokenMint Token mint address to check\n * @param connection Solana connection\n * @returns Balance as a string with proper decimal formatting\n */\nexport async function getTokenBalance(\n  walletAddress: PublicKey,\n  tokenMint: PublicKey,\n  connection: Connection\n): Promise<string> {\n  try {\n    console.log(`Fetching balance for token: ${tokenMint.toString()} for wallet: ${walletAddress.toString()}`);\n    \n    // Check if token is SOL (native)\n    if (tokenMint.equals(TOKENS.SOL)) {\n      console.log(\"Getting native SOL balance\");\n      // For native SOL, get the account info directly\n      const balance = await connection.getBalance(walletAddress);\n      console.log(`Raw SOL balance: ${balance}`);\n      const formattedBalance = formatAmount(balance.toString(), 9); // SOL has 9 decimals\n      console.log(`Formatted SOL balance: ${formattedBalance}`);\n      return formattedBalance;\n    }\n\n    // For SPL tokens, get the associated token account\n    const tokenAccount = await getAssociatedTokenAddress(\n      tokenMint,\n      walletAddress\n    );\n    console.log(`Token account address: ${tokenAccount.toString()}`);\n\n    try {\n      // Get token decimals first\n      let decimals = 9; // Default\n      \n      // Use hardcoded decimals if available\n      const mintString = tokenMint.toString();\n      console.log(`Checking decimals for token: ${mintString}`);\n      \n      if (TOKEN_DECIMALS[mintString]) {\n        decimals = TOKEN_DECIMALS[mintString];\n        console.log(`Using hardcoded decimals: ${decimals}`);\n      } else {\n        // Otherwise query the mint\n        try {\n          console.log(\"Querying mint info for decimals\");\n          const mintInfo = await getMint(connection, tokenMint);\n          decimals = mintInfo.decimals;\n          console.log(`Got decimals from mint: ${decimals}`);\n        } catch (e) {\n          console.error(\"Error getting mint info:\", e);\n          console.log(\"Using default decimals (9)\");\n          // Keep default decimals\n        }\n      }\n      \n      // Now get account info for the token account\n      console.log(\"Fetching token account info\");\n      const account = await getAccount(connection, tokenAccount);\n      console.log(`Raw token amount: ${account.amount.toString()}`);\n      \n      // Format the balance with proper decimals\n      const formattedBalance = formatAmount(account.amount.toString(), decimals);\n      console.log(`Formatted token balance: ${formattedBalance} (using ${decimals} decimals)`);\n      return formattedBalance;\n    } catch (error) {\n      // Check if error is due to account not found\n      if (\n        error instanceof TokenAccountNotFoundError ||\n        error instanceof TokenInvalidAccountOwnerError\n      ) {\n        console.log(\"Token account not found or invalid owner, balance is 0\");\n        // If account doesn't exist, balance is 0\n        return \"0\";\n      }\n      console.error(\"Error getting token account:\", error);\n      throw error;\n    }\n  } catch (error) {\n    console.error(\"Error fetching token balance:\", error);\n    return \"0\";\n  }\n}\n\n// Hook to use in React components\nexport function useJupiterTrade() {\n  const { endpoint } = useContext(ModalContext);\n  const wallet = useWallet();\n  const { publicKey } = wallet;\n\n  /**\n   * Get swap token quote\n   */\n  const getQuote = async (\n    outputMint: PublicKey,\n    inputAmount: number, // decimal number\n    inputMint: PublicKey = TOKENS.USDC,\n    slippageBps: number = DEFAULT_OPTIONS.SLIPPAGE_BPS\n  ) => {\n    try {\n      if (!inputAmount || inputAmount <= 0) throw new Error(\"Invalid token amount\");\n      if (inputMint.equals(outputMint)) throw new Error(\"Input and output tokens must be different\");\n  \n      // Get decimals for input\n      let inputDecimals = TOKEN_DECIMALS[inputMint.toString()] ?? 9;\n      // Scale inputAmount to smallest unit and round down to avoid decimals\n      const scaledAmount = Math.floor(inputAmount * Math.pow(10, inputDecimals));\n      if (scaledAmount <= 0) throw new Error(\"Invalid token amount after conversion\");\n  \n      // Call Jupiter API\n      const quote = await fetchQuote(outputMint, scaledAmount, inputMint, slippageBps, false);\n      if (!quote) throw new Error(\"Unable to get quote\");\n  \n      // Get decimals for output\n      let outputDecimals = TOKEN_DECIMALS[outputMint.toString()] ?? 9;\n      // Format output (decimal number)\n      const outAmount = quote.outAmount ? quote.outAmount : 0;\n      const formattedOutAmount = formatAmount(outAmount, outputDecimals);\n  \n      // Calculate exchange rate\n      const exchangeRate = inputAmount > 0 ? parseFloat(formattedOutAmount) / inputAmount : 0;\n      const priceImpactPct = quote.priceImpactPct ? parseFloat(quote.priceImpactPct) : 0;\n  \n      return {\n        outputAmount: formattedOutAmount,\n        exchangeRate,\n        priceImpactPct,\n        routeInfo: quote.routePlan || null\n      };\n    } catch (error: any) {\n      throw error;\n    }\n  };\n\n  /**\n   * Execute token swap transaction\n   */\n  const executeTrade = async (\n    outputMint: PublicKey,\n    inputAmount: number,\n    inputMint: PublicKey = TOKENS.USDC,\n    slippageBps: number = DEFAULT_OPTIONS.SLIPPAGE_BPS\n  ) => {\n    try {\n      // Check if wallet is connected and has endpoint\n      if (!publicKey || !endpoint) {\n        console.error(\"publicKey or endpoint does not exist:\", { publicKey, endpoint });\n        throw new Error(\"Wallet not connected or endpoint not defined\");\n      }\n\n      // Check input parameters\n      console.log(\"Checking input parameters for trade:\", {\n        inputAmount,\n        inputMintStr: inputMint.toString(),\n        outputMintStr: outputMint.toString(),\n        slippageBps,\n        inputAmountType: typeof inputAmount\n      });\n\n      // Check if inputAmount is a positive number\n      if (typeof inputAmount !== 'number' || isNaN(inputAmount) || inputAmount <= 0) {\n        throw new Error(`Invalid token amount: ${inputAmount}`);\n      }\n\n      // Use wallet directly from useWallet hook\n      console.log(\"Checking wallet details:\", {\n        connected: wallet?.connected,\n        publicKey: publicKey?.toString(),\n        hasSignTransaction: !!wallet?.signTransaction,\n        signTransactionType: typeof wallet?.signTransaction\n      });\n\n      // Check if wallet supports signTransaction method\n      if (!wallet || typeof wallet.signTransaction !== 'function') {\n        throw new Error(\"Wallet does not support signTransaction method\");\n      }\n\n      // Call trade function with full parameters\n      console.log(\"Calling trade function with parameters:\", {\n        outputMint: outputMint.toString(),\n        inputAmount,\n        inputMint: inputMint.toString(),\n        slippageBps,\n        publicKey: publicKey.toString()\n      });\n\n      return await trade(\n        outputMint,\n        inputAmount,\n        inputMint,\n        slippageBps,\n        publicKey.toString(),\n        wallet,\n        endpoint\n      );\n    } catch (error: any) {\n      console.error(\"Error in executeTrade:\", error);\n      throw new Error(`Unable to execute trade: ${error.message}`);\n    }\n  };\n\n  /**\n   * Get balance for a token\n   */\n  const getBalance = async (\n    tokenMint: PublicKey\n  ): Promise<string> => {\n    if (!publicKey || !endpoint) {\n      console.log(\"getBalance: Wallet not connected or endpoint not defined\");\n      return \"0\";\n    }\n    \n    console.log(`getBalance: Checking balance for token ${tokenMint.toString()}`);\n    console.log(`getBalance: Using endpoint ${endpoint}`);\n    console.log(`getBalance: Wallet address ${publicKey.toString()}`);\n    \n    // Create a promise with timeout to avoid hanging\n    const timeoutPromise = new Promise<string>((_, reject) => {\n      setTimeout(() => {\n        reject(new Error(\"getBalance: Connection timeout after 10 seconds\"));\n      }, 10000); // 10 seconds timeout\n    });\n    \n    try {\n      // Race between API call and timeout\n      return await Promise.race([\n        (async () => {\n          // Try using direct connection to Solana RPC\n          try {\n            console.log(\"getBalance: Creating direct connection to Solana RPC\");\n            \n            // Create connection with optimized options\n            const connection = new Connection(endpoint, {\n              commitment: 'confirmed',\n              confirmTransactionInitialTimeout: 10000,\n              disableRetryOnRateLimit: false,\n            });\n            \n            console.log(\"getBalance: Created connection object\");\n            \n            // Skip connection check to avoid 403 error\n            // Go straight to getting SOL balance\n            \n            // Special handling for SOL\n            if (tokenMint.equals(TOKENS.SOL)) {\n              console.log(\"getBalance: Getting SOL balance (special handling)\");\n              try {\n                console.log(`getBalance: Getting SOL balance for wallet ${publicKey.toString()}`);\n                \n                // Use try-catch for each API call\n                const rawBalance = await connection.getBalance(publicKey);\n                console.log(`getBalance: Raw SOL balance in lamports: ${rawBalance}`);\n                \n                // Convert lamports to SOL directly\n                const solBalance = rawBalance / 1000000000;\n                console.log(`getBalance: SOL balance in SOL units: ${solBalance}`);\n                \n                // SPECIAL: Display small SOL with enough decimal places\n                if (solBalance > 0) {\n                  // Always display small SOL balance with fixed format, regardless of size\n                  const formatted = solBalance.toFixed(6);\n                  console.log(`getBalance: Formatted SOL balance for small amount: ${formatted}`);\n                  return formatted;\n                }\n                \n                if (solBalance === 0) {\n                  return \"0\";\n                }\n                \n                // Fallback: Use standard formatter\n                const formattedBalance = formatAmount(rawBalance.toString(), 9);\n                console.log(`getBalance: Formatted SOL balance: ${formattedBalance}`);\n                return formattedBalance;\n              } catch (error) {\n                console.error(\"getBalance: Error getting SOL balance:\", error);\n                return \"0\";\n              }\n            }\n            \n            // For SPL tokens, try getting token account\n            try {\n              // Try simpler method for SPL token instead of using getTokenBalance\n              const tokenAccount = await getAssociatedTokenAddress(\n                tokenMint,\n                publicKey\n              );\n              console.log(`Token account address: ${tokenAccount.toString()}`);\n              \n              try {\n                // Get decimals from hardcoded values instead of querying blockchain\n                const mintString = tokenMint.toString();\n                let decimals = 9; // Default\n                \n                if (TOKEN_DECIMALS[mintString]) {\n                  decimals = TOKEN_DECIMALS[mintString];\n                  console.log(`Using hardcoded decimals: ${decimals}`);\n                }\n                \n                // Get token account info\n                const account = await getAccount(connection, tokenAccount);\n                console.log(`Raw token amount: ${account.amount.toString()}`);\n                \n                // Format balance with correct decimals\n                return formatAmount(account.amount.toString(), decimals);\n              } catch (error) {\n                // Handle case where token account does not exist\n                if (error instanceof TokenAccountNotFoundError) {\n                  console.log(\"Token account not found, balance is 0\");\n                  return \"0\";\n                }\n                console.error(\"Error getting token account:\", error);\n                return \"0\";\n              }\n            } catch (tokenError) {\n              console.error(\"getBalance: Error setting up token account check:\", tokenError);\n              return \"0\";\n            }\n          } catch (connectionError) {\n            console.error(\"getBalance: Could not establish connection:\", connectionError);\n            return \"0\";\n          }\n        })(),\n        timeoutPromise\n      ]);\n    } catch (error) {\n      console.error(\"getBalance: Error getting balance:\", error);\n      return \"0\";\n    }\n  };\n\n  return { executeTrade, getQuote, getBalance };\n}",
      "type": "registry:hook",
      "target": "hook/murphis/use-JupiterTrade.ts"
    },
    {
      "path": "config/swap/index.ts",
      "content": "import { Config } from \"../../types/swap\";\n\nexport const config: Config = {\n  JUPITER_REFERRAL_ACCOUNT: undefined,\n  JUPITER_FEE_BPS: 0,\n};\n",
      "type": "registry:file",
      "target": "config/swap/index.ts"
    },
    {
      "path": "constants/swap/jupiter-constants.ts",
      "content": "import { PublicKey } from \"@solana/web3.js\";\n\nexport const JUP_API = \"https://quote-api.jup.ag/v6\";\nexport const JUP_REFERRAL_ADDRESS = \"JUPTRFXx5qe2wMFBtC7c7s6DvS3weDgAZu7Lr4ZKtoQ\";\n\nexport const DEFAULT_OPTIONS = {\n  SLIPPAGE_BPS: 50, // 0.5%\n};\n\nexport const TOKENS = {\n  SOL: new PublicKey(\"So11111111111111111111111111111111111111112\"),\n  USDC: new PublicKey(\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"),\n  USDT: new PublicKey(\"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB\")\n};",
      "type": "registry:file",
      "target": "constants/swap/jupiter-constants.ts"
    },
    {
      "path": "types/swap/index.ts",
      "content": "import { PublicKey, Connection } from \"@solana/web3.js\";\n\nexport interface Config {\n    JUPITER_REFERRAL_ACCOUNT?: string;\n    JUPITER_FEE_BPS?: number;\n}\n  \ndeclare const _default: {\n    Config: Config;\n};\n\nexport type SolAsset = {\n  mint: PublicKey;\n  name: string;\n  symbol: string;\n  image: string;\n  decimals: number;\n  price: number;\n  userTokenAccount?: {\n    address: PublicKey;\n    amount: number;\n  };\n};\n\nexport default _default; ",
      "type": "registry:file",
      "target": "types/swap/index.ts"
    }
  ]
}