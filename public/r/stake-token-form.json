{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "stake-token-form",
  "type": "registry:block",
  "title": "Stake Token Form",
  "description": "A simple stake token form component.",
  "dependencies": [
    "@solana/web3.js",
    "@solana/spl-token",
    "@solana/wallet-adapter-react"
  ],
  "registryDependencies": [
    "input",
    "button",
    "form",
    "card",
    "sonner",
    "select",
    "dialog",
    "dropdown-menu"
  ],
  "files": [
    {
      "path": "components/ui/murphy/stake-token-form.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect, useMemo, useContext } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { toast } from \"sonner\";\nimport { ArrowDown, Loader2, RefreshCw, Settings } from \"lucide-react\";\nimport {\n  PublicKey,\n  Transaction,\n  LAMPORTS_PER_SOL,\n  VersionedTransaction,\n  clusterApiUrl\n} from \"@solana/web3.js\";\nimport { useWallet, useConnection } from \"@solana/wallet-adapter-react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { ConnectWalletButton } from \"./connect-wallet-button\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { ModalContext } from \"@/components/providers/wallet-provider\";\nimport { cn } from \"@/lib/utils\";\n\n// Type for stake form values\ntype StakeFormValues = {\n  amountToStake: number | undefined;\n};\n\n// Create custom resolver for form\nconst customResolver = (data: any) => {\n  const errors: any = {};\n\n  // Validate amount\n  if (data.amountToStake === undefined || data.amountToStake === null || data.amountToStake === \"\") {\n    errors.amountToStake = {\n      type: \"required\",\n      message: \"Amount is required\",\n    };\n  } else if (Number(data.amountToStake) <= 0) {\n    errors.amountToStake = {\n      type: \"min\",\n      message: \"Amount must be greater than 0\",\n    };\n  }\n\n  return {\n    values: Object.keys(errors).length === 0 ? data : {},\n    errors,\n  };\n};\n\nexport function StakeForm({className}: {className?: string}) {\n  // State variables\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isLoadingBalance, setIsLoadingBalance] = useState(false);\n  const [solBalance, setSolBalance] = useState(\"--\");\n  const [amountToStake, setAmountToStake] = useState<string>(\"\");\n  const [transactionSignature, setTransactionSignature] = useState('');\n  const [currentStage, setCurrentStage] = useState('input'); // input, confirming, success, error\n  const [error, setError] = useState('');\n  \n  const { publicKey, connected, signTransaction } = useWallet();\n  const { connection } = useConnection();\n  const { endpoint } = useContext(ModalContext);\n  \n  // Form setup with react-hook-form\n  const form = useForm<StakeFormValues>({\n    defaultValues: {\n      amountToStake: undefined,\n    },\n    mode: \"onSubmit\",  // Only validate on submit\n    resolver: customResolver,  // Use our custom resolver\n  });\n\n  // Add state to store timeout\n  const [inputTimeout, setInputTimeout] = useState<NodeJS.Timeout | null>(null);\n\n  // Clear timeout when component unmounts\n  useEffect(() => {\n    return () => {\n      if (inputTimeout) {\n        clearTimeout(inputTimeout);\n      }\n    };\n  }, [inputTimeout]);\n\n  // Fetch SOL balance when wallet connects\n  useEffect(() => {\n    if (connected && publicKey) {\n      fetchBalance();\n    } else {\n      setSolBalance('--');\n    }\n  }, [connected, publicKey, connection]);\n\n  // Fetch SOL balance\n  const fetchBalance = async () => {\n    if (!connected || !publicKey || !connection) return;\n    \n    setIsLoadingBalance(true);\n    try {\n      const balance = await connection.getBalance(publicKey);\n      const solBalanceFormatted = (balance / LAMPORTS_PER_SOL).toFixed(6);\n      setSolBalance(solBalanceFormatted);\n      console.log(`fetchBalance: SOL balance = ${solBalanceFormatted}`);\n    } catch (error) {\n      console.error('Error fetching SOL balance:', error);\n      setSolBalance('0');\n      toast.error('Unable to fetch SOL balance', {\n        description: 'Please check your wallet connection',\n      });\n    } finally {\n      setIsLoadingBalance(false);\n    }\n  };\n\n  // Handle use max amount\n  const handleUseMax = (e?: React.MouseEvent) => {\n    // Prevent form submit event if there is an event\n    if (e) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n    \n    if (solBalance !== '--' && parseFloat(solBalance) > 0) {\n      // Keep 0.05 SOL for transaction fees\n      const maxAmount = Math.max(parseFloat(solBalance) - 0.05, 0);\n      setAmountToStake(maxAmount.toString());\n      form.setValue(\"amountToStake\", maxAmount, {\n        shouldValidate: false,\n        shouldDirty: true,\n        shouldTouch: true,\n      });\n    }\n  };\n\n  // Handle amount input change with debounce\n  const handleAmountChange = (value: string) => {\n    if (value === '' || /^\\d*\\.?\\d*$/.test(value)) {\n      setAmountToStake(value);\n      const parsedValue = value === \"\" ? undefined : parseFloat(value);\n      form.setValue(\"amountToStake\", parsedValue, {\n        shouldValidate: false  // Prevent validation\n      });\n    }\n  };\n\n  // Handle form submission - Stake SOL with Solayer\n  const onSubmit = async (values: StakeFormValues) => {\n    if (!connected) {\n      toast.error(\"Wallet not connected\");\n      return;\n    }\n\n    if (!publicKey) {\n      toast.error(\"Public key not found\");\n      return;\n    }\n\n    if (!connection) {\n      toast.error(\"Invalid connection\");\n      return;\n    }\n\n    if (!endpoint) {\n      toast.error(\"RPC endpoint not found\");\n      return;\n    }\n\n    if (!values.amountToStake || values.amountToStake <= 0) {\n      toast.error(\"Invalid amount\");\n      return;\n    }\n\n    // Check SOL balance\n    const inputAmount = values.amountToStake;\n    if (solBalance !== '--' && parseFloat(solBalance) < inputAmount) {\n      // Allow very small discrepancy for SOL (to account for transaction fees)\n      if (inputAmount - parseFloat(solBalance) < 0.001) {\n        console.log(`Detected small discrepancy in SOL balance, proceeding`);\n      } else {\n        toast.error(\"Insufficient SOL balance\");\n        return;\n      }\n    }\n\n    try {\n      setIsSubmitting(true);\n      setError('');\n      setCurrentStage('confirming');\n      \n      // Log transaction information for debugging\n      console.log(\"=== Transaction Information ===\");\n      console.log(\"Endpoint:\", endpoint);\n      console.log(\"Amount:\", values.amountToStake);\n      console.log(\"Wallet connected:\", connected ? \"Yes\" : \"No\");\n      console.log(\"PublicKey:\", publicKey.toString());\n      console.log(\"========================\");\n      \n      // Use internal API route to avoid CORS error\n      const response = await fetch(\n        `/api/murphy/solayer/stake?amount=${parseFloat(amountToStake)}`,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            account: publicKey.toBase58(),\n          }),\n        },\n      );\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || \"Stake request failed\");\n      }\n\n      const data = await response.json();\n\n      // Decode transaction from base64\n      const txBuffer = Buffer.from(data.transaction, \"base64\");\n      \n      // Create VersionedTransaction from received data\n      const tx = VersionedTransaction.deserialize(txBuffer);\n      \n      // Update to latest blockhash\n      const { blockhash } = await connection.getLatestBlockhash();\n      tx.message.recentBlockhash = blockhash;\n      \n      // Sign transaction with user's wallet\n      if (!signTransaction) {\n        throw new Error(\"Wallet does not support transaction signing\");\n      }\n      \n      console.log(\"Signing transaction...\");\n      \n      try {\n        const signedTx = await signTransaction(tx);\n        \n        console.log(\"Sending transaction...\");\n        const signature = await connection.sendRawTransaction(signedTx.serialize());\n        \n        console.log(\"Transaction sent, signature:\", signature);\n        \n        // Wait for transaction confirmation\n        const latestBlockhash = await connection.getLatestBlockhash();\n        await connection.confirmTransaction({\n          signature,\n          blockhash: latestBlockhash.blockhash,\n          lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,\n        });\n        \n        setTransactionSignature(signature);\n        setCurrentStage('success');\n        \n        toast.success(\"Staking successful!\", {\n          description: `Transaction: ${signature}`\n        });\n        \n        // Reset form\n        setAmountToStake(\"\");\n        form.setValue(\"amountToStake\", undefined, {\n          shouldValidate: false\n        });\n        \n        // Refresh balance after successful stake\n        fetchBalance();\n      } catch (signError: any) {\n        console.error('Error signing transaction:', signError);\n        \n        // Analyze user-canceled transaction error\n        if (signError.message && signError.message.includes(\"canceled\")) {\n          toast.error(\"Transaction canceled\", {\n            description: \"You canceled the transaction\"\n          });\n          setError(\"You canceled the transaction\");\n        } else {\n          toast.error(\"Error signing transaction\", {\n            description: signError.message || \"Unable to sign transaction\"\n          });\n          setError(`Error signing transaction: ${signError.message}`);\n        }\n        \n        setCurrentStage('error');\n        throw signError; // Re-throw to handle in finally\n      }\n      \n    } catch (error: any) {\n      console.error('Staking error:', error);\n      \n      // Signing error already handled above, no need to show toast again\n      if (!error.message?.includes(\"canceled\")) {\n        setError(`Staking failed: ${error.message}`);\n        toast.error(\"Transaction failed\", {\n          description: error.message || \"Unable to complete transaction\"\n        });\n      }\n      \n      setCurrentStage('error');\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // Render success view\n  const renderSuccess = () => (\n    <div className=\"space-y-4 p-4 text-center\">\n      <div className=\"mx-auto flex h-20 w-20 items-center justify-center rounded-full bg-green-100\">\n        <svg className=\"h-10 w-10 text-green-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n        </svg>\n      </div>\n      <h3 className=\"text-xl font-bold\">Staking Successful!</h3>\n      <p className=\"text-muted-foreground\">Your SOL has been successfully staked with Solayer.</p>\n      {transactionSignature && (\n        <a \n          href={`https://explorer.solana.com/tx/${transactionSignature}`} \n          target=\"_blank\" \n          rel=\"noopener noreferrer\"\n          className=\"text-primary hover:underline\"\n        >\n          View transaction\n        </a>\n      )}\n      <Button \n        onClick={() => {\n          setCurrentStage('input');\n          setAmountToStake('');\n        }}\n        className=\"w-full\"\n      >\n        Stake more SOL\n      </Button>\n    </div>\n  );\n\n  // Render error view\n  const renderError = () => (\n    <div className=\"space-y-4 p-4 text-center\">\n      <div className=\"mx-auto flex h-20 w-20 items-center justify-center rounded-full bg-red-100\">\n        <svg className=\"h-10 w-10 text-red-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n        </svg>\n      </div>\n      <h3 className=\"text-xl font-bold\">Staking Failed</h3>\n      <p className=\"text-muted-foreground\">{error || 'An error occurred while staking your SOL.'}</p>\n      <Button \n        onClick={() => {\n          setCurrentStage('input');\n        }}\n        className=\"w-full\"\n      >\n        Try Again\n      </Button>\n    </div>\n  );\n\n  // Render confirmation view\n  const renderConfirming = () => (\n    <div className=\"space-y-4 p-4 text-center\">\n      <div className=\"mx-auto flex h-20 w-20 items-center\">\n        <Loader2 className=\"h-10 w-10 animate-spin\" />\n      </div>\n      <h3 className=\"text-xl font-bold\">Confirming Transaction</h3>\n      <p className=\"text-muted-foreground\">Please wait while your staking transaction is being processed...</p>\n    </div>\n  );\n\n  // Render input form\n  const renderInputForm = () => (\n    <Form {...form}>\n      <form \n        onSubmit={(e) => {\n          // Check if clicking MAX button then do not submit\n          const target = e.target as HTMLElement;\n          const maxButton = target.querySelector('.max-button');\n          if (maxButton && (maxButton === document.activeElement || maxButton.contains(document.activeElement as Node))) {\n            e.preventDefault();\n            return;\n          }\n          \n          e.preventDefault();\n          form.handleSubmit(onSubmit)(e);\n        }}\n        className=\"space-y-4\"\n      >\n        <FormField\n          control={form.control}\n          name=\"amountToStake\"\n          render={({ field }) => (\n            <FormItem className=\"bg-secondary/50 rounded-lg p-4\">\n              <div className=\"flex justify-between items-center\">\n                <FormLabel>Stake Amount</FormLabel>\n                <div className=\"flex items-center text-xs text-muted-foreground space-x-1\">\n                  <span>\n                    Balance: {isLoadingBalance ? '...' : solBalance}\n                  </span>\n                  {connected && solBalance !== '--' && parseFloat(solBalance) > 0 && (\n                    <div className=\"max-button-container\" onClick={(e) => e.stopPropagation()}>\n                      <span \n                        className=\"cursor-pointer h-auto py-0 px-2 text-xs text-primary hover:underline max-button\" \n                        onClick={(e) => {\n                          e.preventDefault();\n                          e.stopPropagation();\n                          handleUseMax();\n                        }}\n                      >\n                        MAX\n                      </span>\n                    </div>\n                  )}\n                </div>\n              </div>\n              <div className=\"flex items-center space-x-2 mt-2\">\n                <FormControl>\n                  <Input\n                    type=\"text\"\n                    placeholder=\"0.0\"\n                    value={amountToStake}\n                    onChange={(e) => handleAmountChange(e.target.value)}\n                    disabled={!connected || isSubmitting}\n                    className=\"bg-transparent border-none text-xl font-medium placeholder:text-muted-foreground focus-visible:ring-0 focus-visible:ring-offset-0\"\n                  />\n                </FormControl>\n                <div className=\"min-w-[140px] h-auto bg-background flex items-center justify-center p-2 rounded-md\">\n                  <div className=\"flex items-center\">\n                    <img\n                      src=\"/crypto-logos/solana-logo.svg\"\n                      alt=\"SOL\"\n                      className=\"w-5 h-5 mr-2 rounded-full\"\n                      onError={(e) => {\n                        console.log(\"Error loading SOL logo, using fallback\");\n                        e.currentTarget.src = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNpcmNsZSI+PGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTAiLz48L3N2Zz4=\"; \n                      }}\n                    />\n                    SOL\n                  </div>\n                </div>\n              </div>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n\n        <div className=\"space-y-4\">\n          <div className=\"bg-secondary/50 rounded-lg p-4 space-y-2\">\n            <div className=\"flex justify-between items-center text-sm\">\n              <span>Staking Platform</span>\n              <span className=\"font-medium\">Solayer</span>\n            </div>\n            \n            <div className=\"flex justify-between items-center text-sm\">\n              <span>Reward Token</span>\n              <span className=\"font-medium\">sSOL</span>\n            </div>\n            \n            <div className=\"flex justify-between items-center text-sm\">\n              <span>Estimated APY</span>\n              <span className=\"font-medium\">9.26%</span>\n            </div>\n            \n            <div className=\"flex justify-between items-center text-sm\">\n              <span>Fee</span>\n              <span className=\"font-medium\">0%</span>\n            </div>\n          </div>\n          \n          <div className=\"pt-2\">\n            {!connected ? (\n              <ConnectWalletButton className=\"w-full\" />\n            ) : (\n              <Button\n                type=\"submit\"\n                className=\"w-full\"\n                disabled={\n                  isSubmitting ||\n                  !amountToStake ||\n                  parseFloat(amountToStake) <= 0 || \n                  (solBalance !== '--' && parseFloat(solBalance) < parseFloat(amountToStake) && \n                   !(parseFloat(amountToStake) - parseFloat(solBalance) < 0.001))\n                }\n              >\n                {isSubmitting ? (\n                  <>\n                    <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\n                    Staking...\n                  </>\n                ) : (\n                  (solBalance !== '--' && parseFloat(solBalance) < parseFloat(amountToStake) && \n                  !(parseFloat(amountToStake) - parseFloat(solBalance) < 0.001))\n                    ? 'Insufficient SOL balance'\n                    : 'Stake SOL'\n                )}\n              </Button>\n            )}\n          </div>\n        </div>\n      </form>\n    </Form>\n  );\n\n  // Render based on current stage\n  const renderStageContent = () => {\n    switch (currentStage) {\n      case 'success':\n        return renderSuccess();\n      case 'error':\n        return renderError();\n      case 'confirming':\n        return renderConfirming();\n      default:\n        return renderInputForm();\n    }\n  };\n\n  return (\n    <Card className={cn(\"w-full\", className)}>\n      <CardHeader>\n        <CardTitle className=\"flex items-center justify-between\">\n          <span>Stake SOL</span>\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        {renderStageContent()}\n      </CardContent>\n    </Card>\n  );\n}\n\nexport default StakeForm;",
      "type": "registry:component",
      "target": "components/ui/murphy/stake-token-form.tsx"
    },
    {
      "path": "app/api/murphy/solayer/stake/route.ts",
      "content": "// @ts-nocheck\nimport { NextRequest, NextResponse } from 'next/server';\n\n/**\n * Route handler for Solayer stake API\n * Acts as a proxy to avoid CORS errors\n */\nexport async function POST(request: NextRequest) {\n  try {\n    // Retrieve the amount parameter from the URL\n    const searchParams = request.nextUrl.searchParams;\n    const amount = searchParams.get('amount');\n\n    if (!amount) {\n      return NextResponse.json(\n        { error: 'Amount is required' },\n        { status: 400 }\n      );\n    }\n\n    // Retrieve account information from the request body\n    const body = await request.json();\n    const { account } = body;\n\n    if (!account) {\n      return NextResponse.json(\n        { error: 'Wallet address is required' },\n        { status: 400 }\n      );\n    }\n\n    // Call Solayer API\n    const response = await fetch(\n      `https://app.solayer.org/api/action/restake/ssol?amount=${amount}`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          account,\n        }),\n      }\n    );\n\n    // Retrieve the result from Solayer API\n    const data = await response.json();\n\n    // If the request is unsuccessful, return an error\n    if (!response.ok) {\n      return NextResponse.json(\n        { error: data.message || 'Stake request failed' },\n        { status: response.status }\n      );\n    }\n\n    // Return the successful result\n    return NextResponse.json(data);\n  } catch (error: any) {\n    console.error('Error in Solayer stake API route:', error);\n    return NextResponse.json(\n      { error: error.message || 'An error occurred' },\n      { status: 500 }\n    );\n  }\n}",
      "type": "registry:file",
      "target": "app/api/murphy/solayer/stake/route.ts"
    }
  ]
}